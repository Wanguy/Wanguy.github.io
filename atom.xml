<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gavin&#39;s Blog</title>
  <subtitle>Hello, World</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-18T17:20:35.643Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Richard Gavin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从正态分布到置信区间</title>
    <link href="http://yoursite.com/2018/06/18/%E4%BB%8E%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83%E5%88%B0%E7%BD%AE%E4%BF%A1%E5%8C%BA%E9%97%B4/"/>
    <id>http://yoursite.com/2018/06/18/从正态分布到置信区间/</id>
    <published>2018-06-18T14:16:25.971Z</published>
    <updated>2018-06-18T17:20:35.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先从人均收入说起"><a href="#先从人均收入说起" class="headerlink" title="先从人均收入说起"></a>先从人均收入说起</h2><p>我们通常会统计一个地区的人均收入水平，以此来反应这个地区的经济发展水平。假设现在从一个地区，随机抽取1000人，统计他们的年收入，求和后除以1000，得到一个平均年收入：<br>$$<br>\overline{X}=\frac{1}{1000}\sum_{i=1}^{1000}X_i \qquad（X_i为第i个人的年收入）<br>$$<br>但是这里有一个显而易见的问题，由于每次随机抽取的样本不尽相同，导致算出的算术平均值每次都可能不同。例如第一次$\overline{X_1}=6200$，第二次$\overline{X_2}=6000$，第三次$\overline{X_3}=6100$……，这样得到的数据，让人不知道该相信哪个。</p>
<a id="more"></a>
<h2 id="从抽样到客观"><a href="#从抽样到客观" class="headerlink" title="从抽样到客观"></a>从抽样到客观</h2><p>通过以上的例子，我们得出了一个结论：以点估点是靠不住的，更何况在连续型随机变量中，取一个点的概率是测不到的。但是，这并不意味着平均收入值是不存在的。即一定有那么一个客观存在的值，不因抽样的不同而改变，我们不妨记这个数为 $\mu$ 。</p>
<p>我们回到统计中，假设现在有一组灯泡，我们该如何去估计平均寿命呢？我们同样去抽取一组样本，测量它们的平均寿命 $\overline{X}$ ，虽然这个 $\overline{X}$ 不会正好就是 $\mu$ ，但是我们从常理可知，这个值应该与真实存在的 $\mu$ 相去不远。也就是说，在如果一组灯泡的真实平均寿命是1800小时，我们测得的平均值应该在1800左右，而不会出现例如20，100这样明显偏离的值。那么计算我们测得的 $\overline{X}$ 与 $\mu$ 的距离：<br>$$<br>|\overline{X}-\mu|<br>$$<br>然后计算这个距离小于某个值得概率：<br>$$<br>P(|\overline{X}-\mu|&lt;\Delta)=1-\alpha<br>$$<br>这里，我们便称 $1-\alpha$ 为<strong>置信度</strong>。通俗的解释就是可以相信你给出的这个数据的程度。假设取 $\alpha=0.01$ ，那么就表示为：有90%的把握相信这个概率会发生。在不同的行业，对置信度的精度要求不同。例如航空器材中，对每个零件的精度要求都很高，而相对于普通制衣工厂，对于布料尺寸的把控就没有那么严格。</p>
<h2 id="正态分布和标准化"><a href="#正态分布和标准化" class="headerlink" title="正态分布和标准化"></a>正态分布和标准化</h2><p>普天之下，所有的分布，最终都会归于正态分布：</p>
<p>如果 $X$ 的概率密度为：<br>$$<br>f(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}} \qquad (-\infty&lt;x&lt;+\infty)<br>$$</p>
<p>其中 $-\infty&lt;\mu&lt;+\infty$ ，$\sigma&gt;0$ ，则称 $X$ 服从参数为 $(\mu,\sigma^2)$ 的<strong>正态分布</strong>，或称 $X$ 为<strong>正态变量</strong>，记 $X\sim N (\mu,\sigma^2)$ 。</p>
<p>由于 $(\mu,\sigma^2)$ 的不同，所画出的函数图像也就不同，于是我们希望构造出一个标准化的形式，来研究他的属性。那么用 $X$ 减去自己的期望并除以标准差后，我们能得到 $X$ 的标准化形式，即：<br>$$<br>\frac{X-EX}{\sqrt{DX}}<br>$$<br>对于正态分布来说即为：<br>$$<br>\frac{X-\mu}{\sigma} \sim N(0,1)<br>$$<br><img src="https://lh3.googleusercontent.com/-oie8_LXV_5w/WyfmW2fLN8I/AAAAAAAABTE/Iqh_m3FLJmo6FhlXaCkzPUU41C9daTtzgCHMYCw/I/geogebra-export.png" alt="geogebra-export"><br>现在假设有一组数据：<br>$$<br>(x_1,x_2…x_n) \overset{iid}{\sim}N(\mu,\sigma^2)<br>$$<br>它的<br>$$<br>E\overline{X}=E\frac{(x_1+x_2+…+x_n)}{n}=\frac{1}{n}\cdot n\mu=\mu<br>$$</p>
<p>$$<br>D\overline{X}=D\frac{(x_1+x_2+…+x_n)}{n}=\frac{1}{n^2}\cdot n\sigma^2=\frac{\sigma^2}{n}<br>$$</p>
<p>平均值波动为原样本的 $\frac{1}{n}$ ，波动程度缩小，则 $\overline{X} \sim N(\mu, \frac{\sigma^2}{n})$ 。</p>
<p>我们回到最开始的概率：<br>$$<br>P(|\overline{X}-\mu|&lt;\Delta)=1-\alpha<br>$$<br>通过上面的推导，我们欲对其标准化，因为 $\frac{\sigma^2}{n}&gt;0$ ，所以只需两端同时除以 $\frac{\sigma^2}{n}$ 即可<br>$$<br>P(|\frac{\overline{X}-\mu}{\frac{\sigma^2}{n}}|&lt; \frac{\Delta}{\frac{\sigma^2}{n}})=1-\alpha<br>$$<br>那么它就是一个服从标准正态分布的随机变量的概率分布。</p>
<h2 id="区间估计"><a href="#区间估计" class="headerlink" title="区间估计"></a>区间估计</h2><p>为方便理解，我把上式中 $\frac{\overline{X}-\mu}{\frac{\sigma^2}{n}} $ 记为 $U$ ，把 $\frac{\Delta}{\frac{\sigma^2}{n}}$ 记为 $Q \quad (Q为常数)$<br>$$<br>P(\vert U \vert &lt; Q)=1-\alpha<br>$$</p>
<p>$$<br>P(-Q&lt;U&lt;Q)=1-\alpha<br>$$</p>
<p>根据上 $\alpha$ 分位数，$\alpha$ 的下标代表图像右侧的面积<br><img src="https://lh3.googleusercontent.com/-BqUKrbsLS9s/WyfmQOvYCYI/AAAAAAAABS8/Q-00W59fTEo_JbbultPoksKdKklHG4gfQCHMYCw/I/geogebra-export%2B%25281%2529.png" alt="geogebra-export -1-"></p>
<p>$$<br>P(\vert U \vert &lt; U_\frac{\alpha}{2})=1-\alpha<br>$$</p>
<p>则</p>
<p>$$<br>\frac{\Delta}{\frac{\sigma}{\sqrt{n}}}=U_\frac{\alpha}{2}<br>$$</p>
<p>$$<br>\Delta=U_\frac{\alpha}{2} \cdot \frac{\sigma}{\sqrt{n}}<br>$$</p>
<p>代回原式</p>
<p>$$<br>P(|\overline{X}-\mu|&lt;U_\frac{\alpha}{2} \cdot \frac{\sigma}{\sqrt{n}})=1-\alpha<br>$$</p>
<p>这里的意思就为</p>
<p>$$<br>P(\vert 一次抽样的均值 - 客观存在的均值 \vert &lt; 常数)=1-\alpha<br>$$</p>
<p>那么</p>
<p>$$<br>\overline{X}-U<em>\frac{\alpha}{2} \cdot \frac{\sigma}{\sqrt{n}}&lt;\mu&lt;\overline{X}+U</em>\frac{\alpha}{2} \cdot \frac{\sigma}{\sqrt{n}}<br>$$</p>
<p><img src="https://lh3.googleusercontent.com/-ZufUIaMhHWk/WyfmDyhdkKI/AAAAAAAABS4/cR9MyQNMULkFJQteGuZnlxj5UpA-T6FlgCHMYCw/I/geogebra-export%2B%25282%2529.png" alt="geogebra-export -2-"><br>也就是落入 $(\overline{X}-δ,\overline{X}+δ)$ 之间的概率，即叫做<strong>区间估计</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;先从人均收入说起&quot;&gt;&lt;a href=&quot;#先从人均收入说起&quot; class=&quot;headerlink&quot; title=&quot;先从人均收入说起&quot;&gt;&lt;/a&gt;先从人均收入说起&lt;/h2&gt;&lt;p&gt;我们通常会统计一个地区的人均收入水平，以此来反应这个地区的经济发展水平。假设现在从一个地区，随机抽取1000人，统计他们的年收入，求和后除以1000，得到一个平均年收入：&lt;br&gt;$$&lt;br&gt;\overline{X}=\frac{1}{1000}\sum_{i=1}^{1000}X_i \qquad（X_i为第i个人的年收入）&lt;br&gt;$$&lt;br&gt;但是这里有一个显而易见的问题，由于每次随机抽取的样本不尽相同，导致算出的算术平均值每次都可能不同。例如第一次$\overline{X_1}=6200$，第二次$\overline{X_2}=6000$，第三次$\overline{X_3}=6100$……，这样得到的数据，让人不知道该相信哪个。&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
    
      <category term="Statistics" scheme="http://yoursite.com/tags/Statistics/"/>
    
  </entry>
  
  <entry>
    <title>Mac 局域网共享 ShadowSocks</title>
    <link href="http://yoursite.com/2018/02/05/Mac%E5%B1%80%E5%9F%9F%E7%BD%91%E5%85%B1%E4%BA%ABss/"/>
    <id>http://yoursite.com/2018/02/05/Mac局域网共享ss/</id>
    <published>2018-02-05T08:35:20.309Z</published>
    <updated>2018-02-05T10:03:31.863Z</updated>
    
    <content type="html"><![CDATA[<p>新买了 NS，却发现下载速度慢，切自身无法连接 ss，于是找到了将 macOS 的全局网络在局域网下分享给其他设备的方法。</p>
<a id="more"></a>
<h2 id="安装-ShadowSocks"><a href="#安装-ShadowSocks" class="headerlink" title="安装 ShadowSocks"></a>安装 ShadowSocks</h2><p>安装<strong>ShadowSocks</strong>略过，无论是GUI版还是命令行版都可以，可以参考<a href="http://salogs.com/news/2016/11/02/mac-shadowsocks/" target="_blank" rel="external">这里</a>。</p>
<h2 id="配置-ShadowSocks"><a href="#配置-ShadowSocks" class="headerlink" title="配置 ShadowSocks"></a>配置 ShadowSocks</h2><p>地址端口自行配置，这里要记住的两个地方：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">"local_address":"0.0.0.0",</div><div class="line">"local_port":1080,</div></pre></td></tr></table></figure>
<ul>
<li><code>local_address</code> 这里填写 <code>0.0.0.0</code> 表示局域网点的所有机子都可以通过 <code>1080</code> 这个端口代理，也可以就用主机地址 <code>127.0.0.1</code></li>
<li><code>local_port</code> 端口号不要重复，如果有 <code>HTTPS</code> 代理时尤为注意，同时这个需要记住，之后用到</li>
</ul>
<h2 id="Privoxy"><a href="#Privoxy" class="headerlink" title="Privoxy"></a>Privoxy</h2><p>Windows 系统可以通过几个命令，甚至是客户端的选项就可以完成代理<br><img src="https://lh3.googleusercontent.com/-wAiXakN3028/WngrqgUkMOI/AAAAAAAAAc4/cEjbWN4WqAswvggvNXrU55HYK047Q6JbQCHMYCw/I/a75c3e80gw1f4urdcywyqj206506imxj.jpg" alt="a75c3e80gw1f4urdcywyqj206506imxj"></p>
<p>可惜的是，macOS 没有提供这样的功能，所以我们需要借助像 <a href="http://www.privoxy.org/" target="_blank" rel="external">Privoxy</a> 这样的工具来实现Sock5共享。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>这里分享的是使用 <strong>Homebrew</strong> 安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install privoxy</div></pre></td></tr></table></figure>
<p><strong>homebrew </strong>会报错 <code>/usr/local/sbin is not writable</code>，这是因为 <code>/usr/local/</code> 这个目录不属于当前用户，所以 <strong>homebrew</strong> 无法访问。解决方法为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo mkdir /usr/<span class="built_in">local</span>/sbin</div><div class="line">sudo chown -R `whoami`:admin /usr/<span class="built_in">local</span>/sbin</div></pre></td></tr></table></figure>
<p>之后运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew link privoxy</div></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim /usr/<span class="built_in">local</span>/etc/privoxy/config</div></pre></td></tr></table></figure>
<ol>
<li><p>在 vim 中搜索 <code>forward-socks5t  /</code> ，去掉注释，将端口改为 <code>local_port</code> 号</p>
<blockquote>
<p><code>forward-socks5t / 127.0.0.1:1080</code></p>
</blockquote>
</li>
<li><p>搜索 <code>listen-address 127.0.0.1:8118</code> ，去掉注释，把 <code>127.0.0.1</code> 改为 <code>0.0.0.0</code>，端口号默认或选择一个未占用的端口 </p>
<blockquote>
<p><code>listen-address 0.0.0.0:6666</code> </p>
</blockquote>
</li>
<li><p>修改这两处后，保存并退出即可</p>
</li>
</ol>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /usr/<span class="built_in">local</span>/sbin/privoxy /usr/<span class="built_in">local</span>/etc/privoxy/config &amp;</div></pre></td></tr></table></figure>
<blockquote>
<p>最后的 <code>&amp;</code> 是为了让 privoxy 在后台运行</p>
<p>参见：</p>
<p><a href="http://ju.outofmemory.cn/entry/251730" target="_blank" rel="external">http://ju.outofmemory.cn/entry/251730</a></p>
<p><a href="http://my.oschina.net/u/994235/blog/296702" target="_blank" rel="external">http://my.oschina.net/u/994235/blog/296702</a></p>
</blockquote>
<h3 id="获取本机-IP"><a href="#获取本机-IP" class="headerlink" title="获取本机 IP"></a>获取本机 <code>IP</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifconfig | grep <span class="string">'inet'</span></div></pre></td></tr></table></figure>
<p>其中 <code>inet</code> 后即为本机 <code>IP</code></p>
<h3 id="将-Privoxy-添加到开机启动中"><a href="#将-Privoxy-添加到开机启动中" class="headerlink" title="将 Privoxy 添加到开机启动中"></a>将 Privoxy 添加到开机启动中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 添加开机启动:</span></div><div class="line">ln -sfv /usr/<span class="built_in">local</span>/opt/privoxy/*.plist ~/Library/LaunchAgents  </div><div class="line"><span class="comment"># 启动 Privoxy:</span></div><div class="line">launchctl load ~/Library/LaunchAgents/homebrew.mxcl.privoxy.plist  </div><div class="line"><span class="comment"># 如果不需要用 launchctl 就直接运行:</span></div><div class="line">privoxy /usr/<span class="built_in">local</span>/etc/privoxy/config</div></pre></td></tr></table></figure>
<h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ps aux | grep privoxy</div><div class="line"><span class="comment"># 如果返回如下则说明启动成功</span></div><div class="line">root             34090   0.0  0.0  4278700   1196   ??  Ss    5:39PM   0:00.01 /usr/<span class="built_in">local</span>/sbin/privoxy /usr/<span class="built_in">local</span>/etc/privoxy/config</div></pre></td></tr></table></figure>
<h4 id="查看端口监听"><a href="#查看端口监听" class="headerlink" title="查看端口监听"></a>查看端口监听</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">netstat -an | grep 6666</div><div class="line"><span class="comment"># 如果返回如下则说明启动成功</span></div><div class="line">tcp4       0      0  *.6666                 *.*                    LISTEN</div></pre></td></tr></table></figure>
<h3 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h3><p>先查看进程ID：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ps aux | grep privoxy</div><div class="line"><span class="comment"># 返回 id 为 34090</span></div><div class="line">root             34090   0.0  0.0  4278700   1196   ??  Ss    5:39PM   0:00.01 /usr/<span class="built_in">local</span>/sbin/privoxy /usr/<span class="built_in">local</span>/etc/privoxy/config</div></pre></td></tr></table></figure>
<p>然后：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo <span class="built_in">kill</span> 34090</div></pre></td></tr></table></figure>
<p>当然，也可以直接根据<code>privoxy</code>进程名来关闭Privoxy：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo killall privoxy</div></pre></td></tr></table></figure>
<h3 id="使用快捷短语"><a href="#使用快捷短语" class="headerlink" title="使用快捷短语"></a>使用快捷短语</h3><p>通过给以上命令别名（alias）来快速操作和查看</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim ./.bashrc</div></pre></td></tr></table></figure>
<p>如果使用的是 <strong>zsh</strong>，则</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim ./.zshrc</div></pre></td></tr></table></figure>
<p>在底部插入如下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># privoxy</span></div><div class="line"><span class="built_in">alias</span> privoxy=<span class="string">"sudo /usr/local/sbin/privoxy /usr/local/etc/privoxy/config;"</span></div><div class="line"><span class="built_in">alias</span> privoxy_status=<span class="string">"ps aux | grep privoxy;"</span></div><div class="line"><span class="built_in">alias</span> privoxy_port=<span class="string">"netstat -an | grep 6666;"</span></div><div class="line"><span class="built_in">alias</span> privoxy_quit=<span class="string">"sudo killall privoxy;"</span></div></pre></td></tr></table></figure>
<blockquote>
<p>这里为 <code>alias 别名=&quot;命令;&quot;</code> ，别名可以填自己喜欢的，命令需要和之前的一致</p>
</blockquote>
<p>之后重启 <strong>Terminal</strong> 就可以通过别名来快速操作了</p>
<h2 id="在其他设备使用"><a href="#在其他设备使用" class="headerlink" title="在其他设备使用"></a>在其他设备使用</h2><p>支持手动配置代理的设备，在同一个WiFi下，即可手动配置，以NS为例：</p>
<p><img src="https://lh3.googleusercontent.com/-EY2wdqh7lOQ/Wngr3VXdGHI/AAAAAAAAAc8/rUKmtLmMraAVK6rVgQxJyJwWiott_2QigCHMYCw/I/DVQw1YoVQAEq-Ez.jpg" alt="DVQw1YoVQAEq-Ez"></p>
<p><strong>Proxy Setting</strong> 下，<code>Server</code> 为主机 <code>IP</code>，<code>Port</code> 为 <code>listen-address</code> 的端口号。同理iPhone，PS4等设备也就可以通过这些配置来实现科学上网了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新买了 NS，却发现下载速度慢，切自身无法连接 ss，于是找到了将 macOS 的全局网络在局域网下分享给其他设备的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Tutorial" scheme="http://yoursite.com/categories/Tutorial/"/>
    
    
      <category term="ShadowSocks" scheme="http://yoursite.com/tags/ShadowSocks/"/>
    
  </entry>
  
  <entry>
    <title>使用Google Drive作为Blog的图床</title>
    <link href="http://yoursite.com/2017/12/10/%E4%BD%BF%E7%94%A8Google%20Drive%E4%BD%9C%E4%B8%BABlog%E7%9A%84%E5%9B%BE%E5%BA%8A/"/>
    <id>http://yoursite.com/2017/12/10/使用Google Drive作为Blog的图床/</id>
    <published>2017-12-10T13:36:30.436Z</published>
    <updated>2018-02-05T10:10:43.053Z</updated>
    
    <content type="html"><![CDATA[<p>有时候会碰到需要在blog或者GitHub写一些东西的时候需要用到图片，微博图床总是失效，于是想到可以使用Google Drive作为图床使用。</p>
<a id="more"></a>
<p>登陆Google Drive上传图片之后点击获取链接，我们会得到一个如下的URL地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://drive.google.com/open?id=YOUR_FILE_ID&amp;authuser=0</div></pre></td></tr></table></figure>
<p>但是这个地址是无法直接作为image的src值的，我们需要稍微做一点修改(你必须设置一下google的共享属性<strong>知道此链接的任何人都可以查看</strong>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://drive.google.com/uc?export=view&amp;id=YOUR_FILE_ID</div></pre></td></tr></table></figure>
<p>如果需要让这个文件直接支持下载的话，请使用如下地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://drive.google.com/uc?export=download&amp;id=YOUR_FILE_ID</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候会碰到需要在blog或者GitHub写一些东西的时候需要用到图片，微博图床总是失效，于是想到可以使用Google Drive作为图床使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
    
      <category term="MarkDown" scheme="http://yoursite.com/tags/MarkDown/"/>
    
  </entry>
  
  <entry>
    <title>Swift UILabel 属性</title>
    <link href="http://yoursite.com/2017/12/10/Swift-UILabel-%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2017/12/10/Swift-UILabel-属性/</id>
    <published>2017-12-09T16:04:19.261Z</published>
    <updated>2018-02-05T10:11:09.591Z</updated>
    
    <content type="html"><![CDATA[<p>Swift 中的 UILabel 属性</p>
<a id="more"></a>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> UIKit</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</div><div class="line">       <span class="keyword">super</span>.viewDidLoad()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">//设置标签x坐标：10，y坐标：20，长：300，宽：100</span></div><div class="line">        <span class="keyword">let</span> label = <span class="type">UILabel</span>(frame:<span class="type">CGRectMake</span>(<span class="number">10</span>,<span class="number">20</span>, <span class="number">300</span>, <span class="number">100</span>))</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">//    显示文本【需要显示什么就设置这个 text 的属性即可】</span></div><div class="line">      label.text=<span class="string">" Welcome to study Swift ！"</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// label的字体颜色</span></div><div class="line">        label.textColor=<span class="type">UIColor</span>.redColor() <span class="comment">//红色文字</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// label的背景颜色</span></div><div class="line">        label.backgroundColor=<span class="type">UIColor</span>.blackColor() <span class="comment">//黑色背景</span></div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">        <span class="comment">// label的文字对齐方式</span></div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">          case Left（左对齐）</span></div><div class="line"><span class="comment">          case Center（居中）</span></div><div class="line"><span class="comment">          case Right（右对齐）</span></div><div class="line"><span class="comment">         */</span></div><div class="line">         </div><div class="line">        label.textAlignment=<span class="type">NSTextAlignment</span>.<span class="type">Right</span> <span class="comment">//文字右对齐</span></div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">//    label阴影颜色【要设置偏移位置】(字体的阴影颜色)</span></div><div class="line">        label.shadowColor=<span class="type">UIColor</span>.grayColor()  <span class="comment">//灰色阴影</span></div><div class="line"></div><div class="line"> </div><div class="line"> </div><div class="line"></div><div class="line">        <span class="comment">//    label阴影偏移位置</span></div><div class="line">        label.shadowOffset=<span class="type">CGSizeMake</span>(-<span class="number">5</span>,<span class="number">5</span>)   <span class="comment">//阴影的偏移量</span></div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">//    多行显示，默认是一行的,0表示的多行显示（与高度有关）Label自适应自动换行</span></div><div class="line">        label.numberOfLines=<span class="number">0</span>   <span class="comment">//显示两行文字（默认只显示一行，设为0表示没有行数限制）</span></div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">        <span class="comment">//    自适应（不建议使用）</span></div><div class="line"></div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">              1、没有设置多行显示：宽度自适应</span></div><div class="line"><span class="comment">              2、设置有多行显示：高度使用</span></div><div class="line"><span class="comment">              */</span></div><div class="line"></div><div class="line">        <span class="comment">// 文本有多大,窗口有多大</span></div><div class="line"></div><div class="line">        <span class="comment">// 细节: 不管高度宽度是否足够，都显示相应的高度</span></div><div class="line"></div><div class="line">        <span class="comment">// 细节: numberOfLines为1,那么就是单行显示</span></div><div class="line"></div><div class="line">        label.adjustsFontSizeToFitWidth=<span class="literal">true</span> <span class="comment">//当文字超出标签宽度时，自动调整文字大小，使其不被截断</span></div><div class="line"></div><div class="line"> </div><div class="line"> </div><div class="line"></div><div class="line">        <span class="comment">// 设置label文本高亮</span></div><div class="line">        label.highlighted = <span class="literal">true</span></div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">        <span class="comment">// 设置label文本高亮颜色</span></div><div class="line">        label.highlightedTextColor = <span class="type">UIColor</span>.greenColor()</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// label圆角属性</span></div><div class="line">        label.layer.masksToBounds = <span class="literal">true</span>;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">        <span class="comment">// label圆角半径</span></div><div class="line">        label.layer.cornerRadius = <span class="number">10</span>;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">        <span class="comment">// label圆角边框颜色</span></div><div class="line">        label.layer.borderColor = <span class="type">UIColor</span>.blueColor().<span class="type">CGColor</span>;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">        <span class="comment">// label圆角边框宽度</span></div><div class="line">        label.layer.borderWidth = <span class="number">1</span>;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">        <span class="comment">//  label的字体大小</span></div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         systemFontOfSize(20) -&gt; UIFont         (文字大小)</span></div><div class="line"><span class="comment">         boldSystemFontOfSize(20) -&gt; UIFont     (加粗类型)</span></div><div class="line"><span class="comment">         italicSystemFontOfSize(20) -&gt; UIFont    (斜体类型)</span></div><div class="line"><span class="comment">         */</span></div><div class="line"></div><div class="line">        label.font = <span class="type">UIFont</span>.systemFontOfSize(<span class="number">50</span>)</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">        <span class="comment">// 设置字体时，同时设置大小</span></div><div class="line">        label.font = <span class="type">UIFont</span>(name:<span class="string">"您好！"</span>, size:<span class="number">50</span>)</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">   </div><div class="line">        <span class="comment">// label的特殊属性</span></div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line"><span class="comment">         case ByWordWrapping // Wrap at word boundaries, default</span></div><div class="line"><span class="comment">         case ByCharWrapping // Wrap at character boundaries</span></div><div class="line"><span class="comment">         case ByClipping // Simply clip</span></div><div class="line"><span class="comment">         case ByTruncatingHead // Truncate at head of line: "...wxyz"</span></div><div class="line"><span class="comment">         case ByTruncatingTail // Truncate at tail of line: "abcd..."</span></div><div class="line"><span class="comment">         case ByTruncatingMiddle // Truncate middle of line:  "ab...yz"</span></div><div class="line"><span class="comment">         */</span></div><div class="line"></div><div class="line">label.lineBreakMode=<span class="type">NSLineBreakMode</span>.<span class="type">ByTruncatingTail</span>  <span class="comment">//隐藏尾部并显示省略号</span></div><div class="line">       label.lineBreakMode=<span class="type">NSLineBreakMode</span>.<span class="type">ByTruncatingMiddle</span>  <span class="comment">//隐藏中间部分并显示省略号</span></div><div class="line"></div><div class="line">   label.lineBreakMode=<span class="type">NSLineBreakMode</span>.<span class="type">ByTruncatingHead</span>  <span class="comment">//隐藏头部并显示省略号</span></div><div class="line"></div><div class="line">        label.lineBreakMode=<span class="type">NSLineBreakMode</span>.<span class="type">ByClipping</span> <span class="comment">//截去多余部分也不显示省略号</span></div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"></div><div class="line">　　 <span class="comment">// 将视图添加到(self.view--&gt;父视图)界面中;  </span></div><div class="line">        <span class="keyword">self</span>.view.addSubview(label);</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">     <span class="comment">// 富文本设置</span></div><div class="line">        <span class="keyword">let</span> attributeString = <span class="type">NSMutableAttributedString</span>(string:<span class="string">"Welcome to study Swift ！"</span>)</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">     </div><div class="line">     </div><div class="line">     <span class="comment">// 从文本0开始6个字符字体HelveticaNeue-Bold,16号字体大小</span></div><div class="line">        attributeString.addAttribute(<span class="type">NSFontAttributeName</span>, value: <span class="type">UIFont</span>(name: <span class="string">"HelveticaNeue-Bold"</span>, size: <span class="number">16</span>)!,range: <span class="type">NSMakeRange</span>(<span class="number">0</span>,<span class="number">6</span>))</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">        </div><div class="line">        </div><div class="line">     <span class="comment">// 设置字体颜色       </span></div><div class="line">    attributeString.addAttribute(<span class="type">NSForegroundColorAttributeName</span>, value: <span class="type">UIColor</span>.blueColor(),range: <span class="type">NSMakeRange</span>(<span class="number">0</span>, <span class="number">3</span>))</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">     </div><div class="line">     <span class="comment">// 设置文字背景颜色       attributeString.addAttribute(NSBackgroundColorAttributeName, value: UIColor.greenColor(),range: NSMakeRange(3,3))</span></div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">        label.attributedText = attributeString</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceiveMemoryWarning</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">super</span>.didReceiveMemoryWarning()</div><div class="line">        <span class="comment">// Dispose of any resources that can be recreated.</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swift 中的 UILabel 属性&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>全局.gitignore</title>
    <link href="http://yoursite.com/2017/11/23/gitignore%20global/"/>
    <id>http://yoursite.com/2017/11/23/gitignore global/</id>
    <published>2017-11-23T08:10:01.054Z</published>
    <updated>2017-11-23T08:10:01.054Z</updated>
    
    <content type="html"><![CDATA[<p>以<code>.DS_Store</code>文件为例：</p>
<h3 id="创建-gitignore-global-文件，将需要忽略的文件类型写入文件"><a href="#创建-gitignore-global-文件，将需要忽略的文件类型写入文件" class="headerlink" title="创建 ~/.gitignore_global 文件，将需要忽略的文件类型写入文件"></a>创建 <code>~/.gitignore_global</code> 文件，将需要忽略的文件类型写入文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch .gitignore_global</div></pre></td></tr></table></figure>
<h3 id="在-gitconfig-中引用"><a href="#在-gitconfig-中引用" class="headerlink" title="在.gitconfig 中引用"></a>在<code>.gitconfig</code> 中引用</h3><p>打开<code>~/.gitconfig</code>，输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[core] </div><div class="line">	excludesfile = /Users/reon/.gitignore_global</div></pre></td></tr></table></figure>
<p>或是通过：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git config --global core.excludesfile/Users/reon/.gitignore_global</div></pre></td></tr></table></figure>
<p>命令来实现。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以&lt;code&gt;.DS_Store&lt;/code&gt;文件为例：&lt;/p&gt;
&lt;h3 id=&quot;创建-gitignore-global-文件，将需要忽略的文件类型写入文件&quot;&gt;&lt;a href=&quot;#创建-gitignore-global-文件，将需要忽略的文件类型写入文件&quot; class=&quot;h
    
    </summary>
    
      <category term="Tutorial" scheme="http://yoursite.com/categories/Tutorial/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>C# 中的委托和事件</title>
    <link href="http://yoursite.com/2017/11/07/Delegates%20and%20events%20in%20Csharp/"/>
    <id>http://yoursite.com/2017/11/07/Delegates and events in Csharp/</id>
    <published>2017-11-07T07:04:49.134Z</published>
    <updated>2017-12-12T00:45:56.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>delegate</code> 和 <code>event</code>在 .Net Framework中的应用非常广泛，然而，较好地理解委托和事件对很多接触C#时间不长的人来说并不容易。本文中，我将通过两个范例由浅入深地讲述什么是委托、为什么要使用委托、事件的由来、.Net Framework中的委托和事件、委托和事件对Observer设计模式的意义，对它们的中间代码也做了讨论。</p>
<a id="more"></a>
<h2 id="将方法作为方法的参数"><a href="#将方法作为方法的参数" class="headerlink" title="将方法作为方法的参数"></a>将方法作为方法的参数</h2><p>我们先不管这个标题如何的绕口，也不管委托究竟是个什么东西，来看下面这两个最简单的方法，它们不过是在屏幕上输出一句问候的话语：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void GreetPeople(string name) &#123;</div><div class="line">    // 做某些额外的事情，比如初始化之类，此处略</div><div class="line">    EnglishGreeting(name);</div><div class="line">&#125;</div><div class="line">public void EnglishGreeting(string name) &#123;</div><div class="line">    Console.WriteLine(&quot;Morning, &quot; + name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>暂且不管这两个方法有没有什么实际意义。<code>GreetPeople</code>用于向某人问好，当我们传递代表某人姓名的<code>name</code>参数，比如说“Jimmy”，进去的时候，在这个方法中，将调用<code>EnglishGreeting</code>方法，再次传递<code>name</code>参数，<code>EnglishGreeting</code>则用于向屏幕输出 “Morning, Jimmy”。</p>
<p>现在假设这个程序需要进行全球化，哎呀，不好了，我是中国人，我不明白“Morning”是什么意思，怎么办呢？好吧，我们再加个中文版的问候方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void ChineseGreeting(string name)&#123;</div><div class="line">    Console.WriteLine(&quot;早上好, &quot; + name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时候，<code>GreetPeople</code>也需要改一改了，不然如何判断到底用哪个版本的<code>Greeting</code>问候方法合适呢？在进行这个之前，我们最好再定义一个枚举作为判断的依据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public enum Language&#123;</div><div class="line">    English, Chinese</div><div class="line">&#125;</div><div class="line">public void GreetPeople(string name, Language lang)&#123;</div><div class="line">    //做某些额外的事情，比如初始化之类，此处略</div><div class="line">    swith(lang)&#123;</div><div class="line">        case Language.English:</div><div class="line">           EnglishGreeting(name);</div><div class="line">           break;</div><div class="line">       case Language.Chinese:</div><div class="line">           ChineseGreeting(name);</div><div class="line">           break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，尽管这样解决了问题，但我不说大家也很容易想到，这个解决方案的可扩展性很差，如果日后我们需要再添加韩文版、日文版，就不得不反复修改枚举和<code>GreetPeople()</code>方法，以适应新的需求。</p>
<p>在考虑新的解决方案之前，我们先看看 <code>GreetPeople</code>的方法签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public void GreetPeople(string name, Language lang)</div></pre></td></tr></table></figure>
<p>我们仅看 <code>string name</code>，在这里，<code>string</code> 是参数类型，<code>name</code> 是参数变量，当我们赋给<code>name</code>字符串“jimmy”时，它就代表“jimmy”这个值；当我们赋给它“张子阳”时，它又代表着“张子阳”这个值。然后，我们可以在方法体内对这个<code>name</code>进行其他操作。哎，这简直是废话么，刚学程序就知道了。</p>
<p>如果你再仔细想想，假如<code>GreetPeople()</code>方法可以接受一个参数变量，这个变量可以代表另一个方法，当我们给这个变量赋值 <code>EnglishGreeting</code>的时候，它代表着 <code>EnglsihGreeting()</code> 这个方法；当我们给它赋值<code>ChineseGreeting</code> 的时候，它又代表着 <code>ChineseGreeting()</code>方法。我们将这个参数变量命名为 <code>MakeGreeting</code>，那么不是可以如同给<code>name</code>赋值时一样，在调用 <code>GreetPeople()</code>方法的时候，给这个<code>MakeGreeting</code> 参数也赋上值么(ChineseGreeting或者EnglsihGreeting等)？然后，我们在方法体内，也可以像使用别的参数一样使用<code>MakeGreeting</code>。但是，由于<code>MakeGreeting</code>代表着一个方法，它的使用方式应该和它被赋的方法(比如ChineseGreeting)是一样的，比如：</p>
<p><code>MakeGreeting(name);</code></p>
<p>好了，有了思路了，我们现在就来改改<code>GreetPeople()</code>方法，那么它应该是这个样子了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void GreetPeople(string name, *** MakeGreeting)&#123;</div><div class="line">    MakeGreeting(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意到 <code>***</code> ，这个位置通常放置的应该是参数的类型，但到目前为止，我们仅仅是想到应该有个可以代表方法的参数，并按这个思路去改写<code>GreetPeople</code>方法，现在就出现了一个大问题：<code>***</code>这个代表着方法的MakeGreeting参数应该是什么类型的？</p>
<blockquote>
<p><strong>NOTE：</strong>这里已不再需要枚举了，因为在给<code>MakeGreeting</code>赋值的时候动态地决定使用哪个方法，是<code>ChineseGreeting</code>还是 <code>EnglishGreeting</code>，而在这个两个方法内部，已经对使用“morning”还是“早上好”作了区分。</p>
</blockquote>
<p>聪明的你应该已经想到了，现在是委托该出场的时候了，但讲述委托之前，我们再看看<code>MakeGreeting</code>参数所能代表的 <code>ChineseGreeting()</code>和<code>EnglishGreeting()</code>方法的签名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public void EnglishGreeting(string name)</div><div class="line">public void ChineseGreeting(string name)</div></pre></td></tr></table></figure>
<p>如同<code>name</code>可以接受<code>String</code>类型的“true”和“1”，但不能接受<code>bool</code>类型的true和int类型的1一样。<strong><code>MakeGreeting</code>的 参数类型定义 应该能够确定 <code>MakeGreeting</code>可以代表的方法种类，再进一步讲，就是<code>MakeGreeting</code>可以代表的方法的参数类型和返回类型。</strong></p>
<p>于是，委托出现了：<strong>它定义了<code>MakeGreeting</code>参数所能代表的方法的种类，也就是<code>MakeGreeting</code>参数的类型。</strong></p>
<blockquote>
<p><strong>NOTE：</strong>如果上面这句话比较绕口，我把它翻译成这样：<code>string</code> 定义了<code>name</code>参数所能代表的<strong>值的种类</strong>，也就是<code>name</code>参数的类型。</p>
</blockquote>
<p>本例中委托的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public delegate void GreetingDelegate(string name);</div></pre></td></tr></table></figure>
<p>可以与上面<code>EnglishGreeting()</code>方法的签名对比一下，除了加入了<code>delegate</code>关键字以外，其余的是不是完全一样？</p>
<p>现在，让我们再次改动<code>GreetPeople()</code>方法，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public void GreetPeople(string name, GreetingDelegate MakeGreeting)&#123;</div><div class="line">    MakeGreeting(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如你所见，委托GreetingDelegate出现的位置与 string相同，string是一个类型，那么GreetingDelegate应该也是一个类型，或者叫类(Class)。但是委托的声明方式和类却完全不同，这是怎么一回事？实际上，委托在编译的时候确实会编译成类。因为Delegate是一个类，所以在任何可以声明类的地方都可以声明委托。更多的内容将在下面讲述，现在，请看看这个范例的完整代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">using System;</div><div class="line">using System.Collections.Generic;</div><div class="line">using System.Text;</div><div class="line">namespace Delegate &#123;</div><div class="line">     //定义委托，它定义了可以代表的方法的类型</div><div class="line">     public delegate void GreetingDelegate(string name);</div><div class="line">        class Program &#123;</div><div class="line">           private static void EnglishGreeting(string name) &#123;</div><div class="line">               Console.WriteLine(&quot;Morning, &quot; + name);</div><div class="line">           &#125;</div><div class="line">           private static void ChineseGreeting(string name) &#123;</div><div class="line">               Console.WriteLine(&quot;早上好, &quot; + name);</div><div class="line">           &#125;</div><div class="line">           //注意此方法，它接受一个GreetingDelegate类型的方法作为参数</div><div class="line">           private static void GreetPeople(string name, GreetingDelegate MakeGreeting) &#123;</div><div class="line">               MakeGreeting(name);</div><div class="line">            &#125;</div><div class="line">           static void Main(string[] args) &#123;</div><div class="line">               GreetPeople(&quot;Jimmy Zhang&quot;, EnglishGreeting);</div><div class="line">               GreetPeople(&quot;张子阳&quot;, ChineseGreeting);</div><div class="line">               Console.ReadKey();</div><div class="line">           &#125;</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Morning, Jimmy Zhang</div><div class="line">早上好, 张子阳</div></pre></td></tr></table></figure>
<p>我们现在对委托做一个总结：</p>
<p><strong>委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，这种将方法动态地赋给参数的做法，可以避免在程序中大量使用<code>If-Else(Switch)</code>语句，同时使得程序具有更好的可扩展性。</strong></p>
<h2 id="将方法绑定到委托"><a href="#将方法绑定到委托" class="headerlink" title="将方法绑定到委托"></a>将方法绑定到委托</h2><p>看到这里，是不是有那么点如梦初醒的感觉？于是，你是不是在想：在上面的例子中，我不一定要直接在<code>GreetPeople()</code>方法中给 <code>name</code>参数赋值，我可以像这样使用变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static void Main(string[] args) &#123;</div><div class="line">    string name1, name2;</div><div class="line">    name1 = &quot;Jimmy Zhang&quot;;</div><div class="line">    name2 = &quot;张子阳&quot;; </div><div class="line">    GreetPeople(name1, EnglishGreeting);</div><div class="line">    GreetPeople(name2, ChineseGreeting);</div><div class="line">    Console.ReadKey();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而既然委托<code>GreetingDelegate</code> 和 类型 <code>string</code> 的地位一样，都是定义了一种参数类型，那么，我是不是也可以这么使用委托？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static void Main(string[] args) &#123;</div><div class="line">    GreetingDelegate delegate1, delegate2;</div><div class="line">    delegate1 = EnglishGreeting;</div><div class="line">    delegate2 = ChineseGreeting;</div><div class="line">    GreetPeople(&quot;Jimmy Zhang&quot;, delegate1);</div><div class="line">    GreetPeople(&quot;张子阳&quot;, delegate2);</div><div class="line">    Console.ReadKey();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如你所料，这样是没有问题的，程序一如预料的那样输出。这里，我想说的是委托不同于<code>string</code>的一个特性：可以将多个方法赋给同一个委托，或者叫将多个方法绑定到同一个委托，当调用这个委托的时候，将依次调用其所绑定的方法。在这个例子中，语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static void Main(string[] args) &#123;</div><div class="line">    GreetingDelegate delegate1;</div><div class="line">    delegate1 = EnglishGreeting; // 先给委托类型的变量赋值</div><div class="line">    delegate1 += ChineseGreeting;   // 给此委托变量再绑定一个方法</div><div class="line">     // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法</div><div class="line">    GreetPeople(&quot;Jimmy Zhang&quot;, delegate1);  </div><div class="line">    Console.ReadKey();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Morning, Jimmy Zhang</div><div class="line">早上好, Jimmy Zhang</div></pre></td></tr></table></figure>
<p>实际上，我们可以也可以绕过GreetPeople方法，通过委托来直接调用EnglishGreeting和ChineseGreeting：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static void Main(string[] args) &#123;</div><div class="line">    GreetingDelegate delegate1;</div><div class="line">    delegate1 = EnglishGreeting; // 先给委托类型的变量赋值</div><div class="line">    delegate1 += ChineseGreeting;   // 给此委托变量再绑定一个方法</div><div class="line">    // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法</div><div class="line">    delegate1 (&quot;Jimmy Zhang&quot;);   </div><div class="line">    Console.ReadKey();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>NOTE：</strong>这在本例中是没有问题的，但回头看下上面GreetPeople()的定义，在它之中可以做一些对于EnglshihGreeting和ChineseGreeting来说都需要进行的工作，为了简便我做了省略。</p>
</blockquote>
<p>注意这里，第一次用的“<code>=</code>”，是赋值的语法；第二次，用的是“<code>+=</code>”，是绑定的语法。如果第一次就使用“<code>+=</code>”，将出现“使用了未赋值的局部变量”的编译错误。</p>
<p>我们也可以使用下面的代码来这样简化这一过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GreetingDelegate delegate1 = new GreetingDelegate(EnglishGreeting);</div><div class="line">delegate1 += ChineseGreeting;   // 给此委托变量再绑定一个方法</div></pre></td></tr></table></figure>
<p>看到这里，应该注意到，这段代码第一条语句与实例化一个类是何其的相似，你不禁想到：上面第一次绑定委托时不可以使用“<code>+=</code>”的编译错误，或许可以用这样的方法来避免：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">GreetingDelegate delegate1 = new GreetingDelegate();</div><div class="line">delegate1 += EnglishGreeting;   // 这次用的是 “+=”，绑定语法。</div><div class="line">delegate1 += ChineseGreeting;   // 给此委托变量再绑定一个方法</div></pre></td></tr></table></figure>
<p>但实际上，这样会出现编译错误： <strong>“GreetingDelegate”方法没有采用“0”个参数的重载</strong>。尽管这样的结果让我们觉得有点沮丧，但是编译的提示：<strong>“没有0个参数的重载”</strong>再次让我们联想到了类的构造函数。我知道你一定按捺不住想探个究竟，但再此之前，我们需要先把基础知识和应用介绍完。</p>
<p><strong>既然给委托可以绑定一个方法，那么也应该有办法取消对方法的绑定，很容易想到，这个语法是“-=”：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static void Main(string[] args) &#123;</div><div class="line">    GreetingDelegate delegate1 = new GreetingDelegate(EnglishGreeting);</div><div class="line">    delegate1 += ChineseGreeting;   // 给此委托变量再绑定一个方法</div><div class="line">    // 将先后调用 EnglishGreeting 与 ChineseGreeting 方法</div><div class="line">    GreetPeople(&quot;Jimmy Zhang&quot;, delegate1);  </div><div class="line">    Console.WriteLine();</div><div class="line">    delegate1 -= EnglishGreeting; //取消对EnglishGreeting方法的绑定</div><div class="line">    // 将仅调用 ChineseGreeting </div><div class="line">    GreetPeople(&quot;张子阳&quot;, delegate1); </div><div class="line">    Console.ReadKey();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Morning, Jimmy Zhang</div><div class="line">早上好, Jimmy Zhang</div><div class="line">早上好, 张子阳</div></pre></td></tr></table></figure>
<p>让我们再次对委托作个总结：</p>
<p><strong>使用委托可以将多个方法绑定到同一个委托变量，当调用此变量时(这里用“调用”这个词，是因为此变量代表一个方法)，可以依次调用所有绑定的方法。</strong></p>
<h2 id="事件的由来"><a href="#事件的由来" class="headerlink" title="事件的由来"></a>事件的由来</h2><p>我们继续思考上面的程序：上面的三个方法都定义在<code>Programe</code>类中，这样做是为了理解的方便，实际应用中，通常都是 <code>GreetPeople</code> 在一个类中，<code>ChineseGreeting</code>和 <code>EnglishGreeting</code> 在另外的类中。现在你已经对委托有了初步了解，是时候对上面的例子做个改进了。假设我们将GreetingPeople()放在一个叫<code>GreetingManager</code>的类中，那么新程序应该是这个样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">namespace Delegate &#123;</div><div class="line">    //定义委托，它定义了可以代表的方法的类型</div><div class="line">    public delegate void GreetingDelegate(string name);</div><div class="line">    //新建的GreetingManager类</div><div class="line">    public class GreetingManager&#123;</div><div class="line">       public void GreetPeople(string name, GreetingDelegate MakeGreeting) &#123;</div><div class="line">           MakeGreeting(name);</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">    class Program &#123;</div><div class="line">       private static void EnglishGreeting(string name) &#123;</div><div class="line">           Console.WriteLine(&quot;Morning, &quot; + name);</div><div class="line">       &#125;</div><div class="line">       private static void ChineseGreeting(string name) &#123;</div><div class="line">           Console.WriteLine(&quot;早上好, &quot; + name);</div><div class="line">       &#125;</div><div class="line">       static void Main(string[] args) &#123;</div><div class="line">           // ... ...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个时候，如果要实现前面演示的输出效果，<code>Main</code>方法我想应该是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">static void Main(string[] args) &#123;</div><div class="line">    GreetingManager gm = new  GreetingManager();</div><div class="line">    gm.GreetPeople(&quot;Jimmy Zhang&quot;, EnglishGreeting);</div><div class="line">    gm.GreetPeople(&quot;张子阳&quot;, ChineseGreeting);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们运行这段代码，嗯，没有任何问题。程序一如预料地那样输出了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Morning, Jimmy Zhang</div><div class="line">早上好, 张子阳</div></pre></td></tr></table></figure>
<p>现在，假设我们需要使用上一节学到的知识，将多个方法绑定到同一个委托变量，该如何做呢？让我们再次改写代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static void Main(string[] args) &#123;</div><div class="line">    GreetingManager gm = new  GreetingManager();</div><div class="line">    GreetingDelegate delegate1;</div><div class="line">    delegate1 = EnglishGreeting;</div><div class="line">    delegate1 += ChineseGreeting;</div><div class="line">    gm.GreetPeople(&quot;Jimmy Zhang&quot;, delegate1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Morning, Jimmy Zhang</div><div class="line">早上好, Jimmy Zhang</div></pre></td></tr></table></figure>
<p>到了这里，我们不禁想到：面向对象设计，讲究的是对象的封装，既然可以声明委托类型的变量(在上例中是delegate1)，我们何不将这个变量封装到 <code>GreetManager</code>类中？在这个类的客户端中使用不是更方便么？于是，我们改写<code>GreetManager</code>类，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class GreetingManager&#123;</div><div class="line">    //在GreetingManager类的内部声明delegate1变量</div><div class="line">    public GreetingDelegate delegate1;  </div><div class="line">    public void GreetPeople(string name, GreetingDelegate MakeGreeting) &#123;</div><div class="line">       MakeGreeting(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，我们可以这样使用这个委托变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static void Main(string[] args) &#123;</div><div class="line">    GreetingManager gm = new  GreetingManager();</div><div class="line">    gm.delegate1 = EnglishGreeting;</div><div class="line">    gm.delegate1 += ChineseGreeting;</div><div class="line">    gm.GreetPeople(&quot;Jimmy Zhang&quot;, gm.delegate1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Morning, Jimmy Zhang</div><div class="line">早上好, Jimmy Zhang</div></pre></td></tr></table></figure>
<p>尽管这样做没有任何问题，但我们发现这条语句很奇怪。在调用gm.GreetPeople方法的时候，再次传递了<code>gm</code>的<code>delegate1</code>字段：</p>
<p><code>gm.GreetPeople(&quot;Jimmy Zhang&quot;, gm.delegate1);</code></p>
<p>既然如此，我们何不修改 <code>GreetingManager</code> 类成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class GreetingManager&#123;</div><div class="line">    //在GreetingManager类的内部声明delegate1变量</div><div class="line">    public GreetingDelegate delegate1;  </div><div class="line">    public void GreetPeople(string name) &#123;</div><div class="line">        if(delegate1!=null)&#123;     //如果有方法注册委托变量</div><div class="line">          delegate1(name);      //通过委托调用方法</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在客户端，调用看上去更简洁一些：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static void Main(string[] args) &#123;</div><div class="line">    GreetingManager gm = new  GreetingManager();</div><div class="line">    gm.delegate1 = EnglishGreeting;</div><div class="line">    gm.delegate1 += ChineseGreeting;</div><div class="line">    gm.GreetPeople(&quot;Jimmy Zhang&quot;);      //注意，这次不需要再传递 delegate1变量</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Morning, Jimmy Zhang</div><div class="line">早上好, Jimmy Zhang</div></pre></td></tr></table></figure>
<p>尽管这样达到了我们要的效果，但是还是存在着问题：</p>
<p>在这里，<code>delegate1</code>和我们平时用的<code>string</code>类型的变量没有什么分别，而我们知道，并不是所有的字段都应该声明成<code>public</code>，合适的做法是应该<code>public</code>的时候<code>public</code>，应该<code>private</code>的时候<code>private</code>。</p>
<p>我们先看看如果把 <code>delegate1</code> 声明为 <code>private</code>会怎样？结果就是：<strong>这简直就是在搞笑。因为声明委托的目的就是为了把它暴露在类的客户端进行方法的注册，你把它声明为<code>private</code>了，客户端对它根本就不可见，那它还有什么用？</strong></p>
<p>再看看把<code>delegate1</code> 声明为 <code>public</code> 会怎样？结果就是：<strong>在客户端可以对它进行随意的赋值等操作，严重破坏对象的封装性。</strong></p>
<p>最后，第一个方法注册用“<code>=</code>”，是赋值语法，因为要进行实例化，第二个方法注册则用的是“<code>+=</code>”。但是，不<strong>管是赋值还是注册，都是将方法绑定到委托上，除了调用时先后顺序不同，再没有任何的分别，这样不是让人觉得很别扭么？</strong></p>
<p>现在我们想想，如果<code>delegate1</code>不是一个委托类型，而是一个<code>string</code>类型，你会怎么做？<strong>答案是使用属性对字段进行封装。</strong></p>
<p>于是，<code>Event</code>出场了，它封装了委托类型的变量，使得：<strong>在类的内部，不管你声明它是<code>public</code>还是<code>protected</code>，它总是<code>private</code>的。在类的外部，注册“<code>+=</code>”和注销“<code>-=</code>”的访问限定符与你在声明事件时使用的访问符相同。</strong></p>
<p>我们改写<code>GreetingManager</code>类，它变成了这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class GreetingManager&#123;</div><div class="line">    //这一次我们在这里声明一个事件</div><div class="line">    public event GreetingDelegate MakeGreet;</div><div class="line">    public void GreetPeople(string name) &#123;</div><div class="line">        MakeGreet(name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>很容易注意到：<code>MakeGreet</code> 事件的声明与之前委托变量<code>delegate1</code>的声明唯一的区别是多了一个<code>event</code>关键字。看到这里，在结合上面的讲解，你应该明白到：<strong>事件其实没什么不好理解的，声明一个事件不过类似于声明一个进行了封装的委托类型的变量而已。</strong></p>
<p>为了证明上面的推论，如果我们像下面这样改写<code>Main</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static void Main(string[] args) &#123;</div><div class="line">    GreetingManager gm = new  GreetingManager();</div><div class="line">    gm.MakeGreet = EnglishGreeting;         // 编译错误1</div><div class="line">    gm.MakeGreet += ChineseGreeting;</div><div class="line">    gm.GreetPeople(&quot;Jimmy Zhang&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会得到编译错误：<code>事件“Delegate.GreetingManager.MakeGreet”只能出现在 += 或 -= 的左边(从类型“Delegate.GreetingManager”中使用时除外)。</code></p>
<h2 id="事件和委托的编译代码"><a href="#事件和委托的编译代码" class="headerlink" title="事件和委托的编译代码"></a>事件和委托的编译代码</h2><p>这时候，我们注释掉编译错误的行，然后重新进行编译，再借助Reflactor来对 <code>event</code>的声明语句做一探究，看看为什么会发生这样的错误：</p>
<p><code>public event GreetingDelegate MakeGreet;</code></p>
<p><img src="http://www.tracefact.net/graph/delegate/01.gif" alt=" "></p>
<p>可以看到，实际上尽管我们在<code>GreetingManager</code>里将 <code>MakeGreet</code> 声明为<code>public</code>，但是，实际上<code>MakeGreet</code>会被编译成 私有字段，难怪会发生上面的编译错误了，因为它根本就不允许在<code>GreetingManager</code>类的外面以赋值的方式访问，从而验证了我们上面所做的推论。</p>
<p>我们再进一步看下<code>MakeGreet</code>所产生的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">private GreetingDelegate MakeGreet; //对事件的声明 实际是 声明一个私有的委托变量</div><div class="line">[MethodImpl(MethodImplOptions.Synchronized)]</div><div class="line">public void add_MakeGreet(GreetingDelegate value)&#123;</div><div class="line">    this.MakeGreet = (GreetingDelegate) Delegate.Combine(this.MakeGreet, value);</div><div class="line">&#125;</div><div class="line">[MethodImpl(MethodImplOptions.Synchronized)]</div><div class="line">public void remove_MakeGreet(GreetingDelegate value)&#123;</div><div class="line">    this.MakeGreet = (GreetingDelegate) Delegate.Remove(this.MakeGreet, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在已经很明确了：<strong><code>MakeGreet</code>事件确实是一个<code>GreetingDelegate</code>类型的委托，只不过不管是不是声明为<code>public</code>，它总是被声明为<code>private</code>。另外，它还有两个方法，分别是<code>add_MakeGreet</code>和<code>remove_MakeGreet</code>，这两个方法分别用于注册委托类型的方法和取消注册。</strong>实际上也就是： “<code>+=</code> ”对应 <code>add_MakeGreet</code>，“<code>-=</code>”对应<code>remove_MakeGreet</code>。而这两个方法的访问限制取决于声明事件时的访问限制符。</p>
<p>在<code>add_MakeGreet()</code>方法内部，实际上调用了<code>System.Delegate</code>的<code>Combine()</code>静态方法，这个方法用于将当前的变量添加到委托链表中。我们前面提到过两次，说委托实际上是一个类，在我们定义委托的时候：</p>
<p><code>public delegate void GreetingDelegate(string name);</code></p>
<p>当编译器遇到这段代码的时候，会生成下面这样一个完整的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public sealed class GreetingDelegate:System.MulticastDelegate&#123;</div><div class="line">    public GreetingDelegate(object @object, IntPtr method);</div><div class="line">    public virtual IAsyncResult BeginInvoke(string name, AsyncCallback callback, object @object);</div><div class="line">    public virtual void EndInvoke(IAsyncResult result);</div><div class="line">    public virtual void Invoke(string name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://www.tracefact.net/graph/delegate/02.gif" alt=" "></p>
<blockquote>
<p>关于这个类的更深入内容，可以参阅《CLR Via C#》等相关书籍，这里就不再讨论了。</p>
</blockquote>
<h2 id="委托、事件与Observer设计模式"><a href="#委托、事件与Observer设计模式" class="headerlink" title="委托、事件与Observer设计模式"></a>委托、事件与Observer设计模式</h2><h3 id="范例说明"><a href="#范例说明" class="headerlink" title="范例说明"></a>范例说明</h3><p>上面的例子已不足以再进行下面的讲解了，我们来看一个新的范例，因为之前已经介绍了很多的内容，所以本节的进度会稍微快一些：</p>
<p>假设我们有个高档的热水器，我们给它通上电，当水温超过95度的时候：</p>
<ol>
<li>扬声器会开始发出语音，告诉你水的温度；</li>
<li>液晶屏也会改变水温的显示，来提示水已经快烧开了。</li>
</ol>
<p>现在我们需要写个程序来模拟这个烧水的过程，我们将定义一个类来代表热水器，我们管它叫：<code>Heater</code>，它有代表水温的字段，叫做<code>temperature</code>；当然，还有必不可少的给水加热方法<code>BoilWater()</code>，一个发出语音警报的方法<code>MakeAlert()</code>，一个显示水温的方法，<code>ShowMsg()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">namespace Delegate &#123;</div><div class="line">    class Heater &#123;</div><div class="line">        private int temperature; // 水温</div><div class="line">        // 烧水</div><div class="line">        public void BoilWater() &#123;</div><div class="line">            for (int i = 0; i &lt;= 100; i++) &#123;</div><div class="line">               temperature = i;</div><div class="line">               if (temperature &gt; 95) &#123;</div><div class="line">                   MakeAlert(temperature);</div><div class="line">                   ShowMsg(temperature);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    // 发出语音警报</div><div class="line">    private void MakeAlert(int param) &#123;</div><div class="line">       Console.WriteLine(&quot;Alarm：嘀嘀嘀，水已经 &#123;0&#125; 度了：&quot; , param);</div><div class="line">    &#125;</div><div class="line">    // 显示水温</div><div class="line">    private void ShowMsg(int param) &#123;</div><div class="line">       Console.WriteLine(&quot;Display：水快开了，当前温度：&#123;0&#125;度。&quot; , param);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    class Program &#123;</div><div class="line">        static void Main() &#123;</div><div class="line">           Heater ht = new Heater();</div><div class="line">           ht.BoilWater();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Observer设计模式简介"><a href="#Observer设计模式简介" class="headerlink" title="Observer设计模式简介"></a>Observer设计模式简介</h3><p>上面的例子显然能完成我们之前描述的工作，但是却并不够好。现在假设热水器由三部分组成：热水器、警报器、显示器，它们来自于不同厂商并进行了组装。那么，应该是<strong>热水器</strong>仅仅负责烧水，它不能发出警报也不能显示水温；在水烧开时由<strong>警报器</strong>发出警报、<strong>显示器</strong>显示提示和水温。</p>
<p>这时候，上面的例子就应该变成这个样子：    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 热水器</div><div class="line">public class Heater &#123; </div><div class="line">    private int temperature;</div><div class="line">    // 烧水</div><div class="line">    private void BoilWater() &#123;</div><div class="line">       for (int i = 0; i &lt;= 100; i++) &#123;</div><div class="line">           temperature = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 警报器</div><div class="line">public class Alarm&#123;</div><div class="line">    private void MakeAlert(int param) &#123;</div><div class="line">       Console.WriteLine(&quot;Alarm：嘀嘀嘀，水已经 &#123;0&#125; 度了：&quot; , param);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">// 显示器</div><div class="line">public class Display&#123;</div><div class="line">    private void ShowMsg(int param) &#123;</div><div class="line">       Console.WriteLine(&quot;Display：水已烧开，当前温度：&#123;0&#125;度。&quot; , param);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就出现了一个问题：如何在水烧开的时候通知报警器和显示器？在继续进行之前，我们先了解一下<code>Observer</code>设计模式，Observer设计模式中主要包括如下两类对象：</p>
<ol>
<li><code>Subject</code>：监视对象，它往往包含着其他对象所感兴趣的内容。在本范例中，热水器就是一个监视对象，它包含的其他对象所感兴趣的内容，就是<code>temprature</code>字段，当这个字段的值快到100时，会不断把数据发给监视它的对象。</li>
<li><code>Observer</code>：监视者，它监视<code>Subject</code>，当<code>Subject</code>中的某件事发生的时候，会告知<code>Observer</code>，而<code>Observer</code>则会采取相应的行动。在本范例中，<code>Observer</code>有警报器和显示器，它们采取的行动分别是发出警报和显示水温。</li>
</ol>
<p>在本例中，事情发生的顺序应该是这样的：</p>
<ol>
<li>警报器和显示器告诉热水器，它对它的温度比较感兴趣(注册)。</li>
<li>热水器知道后保留对警报器和显示器的引用。</li>
<li>热水器进行烧水这一动作，当水温超过95度时，通过对警报器和显示器的引用，自动调用警报器的<code>MakeAlert()</code>方法、显示器的<code>ShowMsg()</code>方法。</li>
</ol>
<p>类似这样的例子是很多的，GOF对它进行了抽象，称为<code>Observer</code>设计模式：<strong><code>Observer</code>设计模式是为了定义对象间的一种一对多的依赖关系，以便于当一个对象的状态改变时，其他依赖于它的对象会被自动告知并更新。<code>Observer</code>模式是一种松耦合的设计模式。</strong></p>
<h3 id="实现范例的Observer设计模式"><a href="#实现范例的Observer设计模式" class="headerlink" title="实现范例的Observer设计模式"></a>实现范例的Observer设计模式</h3><p>我们之前已经对委托和事件介绍很多了，现在写代码应该很容易了，现在在这里直接给出代码，并在注释中加以说明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">using System;</div><div class="line">using System.Collections.Generic;</div><div class="line">using System.Text;</div><div class="line">namespace Delegate &#123;</div><div class="line">    // 热水器</div><div class="line">    public class Heater &#123;</div><div class="line">       private int temperature;</div><div class="line">       public delegate void BoilHandler(int param);   //声明委托</div><div class="line">       public event BoilHandler BoilEvent;        //声明事件</div><div class="line">       // 烧水</div><div class="line">       public void BoilWater() &#123;</div><div class="line">           for (int i = 0; i &lt;= 100; i++) &#123;</div><div class="line">              temperature = i;</div><div class="line">              if (temperature &gt; 95) &#123;</div><div class="line">                  if (BoilEvent != null) &#123; //如果有对象注册</div><div class="line">                      BoilEvent(temperature);  //调用所有注册对象的方法</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">    // 警报器</div><div class="line">    public class Alarm &#123;</div><div class="line">       public void MakeAlert(int param) &#123;</div><div class="line">           Console.WriteLine(&quot;Alarm：嘀嘀嘀，水已经 &#123;0&#125; 度了：&quot;, param);</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">    // 显示器</div><div class="line">    public class Display &#123;</div><div class="line">       public static void ShowMsg(int param) &#123; //静态方法</div><div class="line">           Console.WriteLine(&quot;Display：水快烧开了，当前温度：&#123;0&#125;度。&quot;, param);</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">    class Program &#123;</div><div class="line">       static void Main() &#123;</div><div class="line">           Heater heater = new Heater();</div><div class="line">           Alarm alarm = new Alarm();</div><div class="line">           heater.BoilEvent += alarm.MakeAlert;    //注册方法</div><div class="line">           heater.BoilEvent += (new Alarm()).MakeAlert;   //给匿名对象注册方法</div><div class="line">           heater.BoilEvent += Display.ShowMsg;       //注册静态方法</div><div class="line">           heater.BoilWater();   //烧水，会自动调用注册过对象的方法</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Alarm：嘀嘀嘀，水已经 96 度了：</div><div class="line">Alarm：嘀嘀嘀，水已经 96 度了：</div><div class="line">Display：水快烧开了，当前温度：96度。</div><div class="line">// 省略...</div></pre></td></tr></table></figure>
<h2 id="Net-Framework中的委托与事件"><a href="#Net-Framework中的委托与事件" class="headerlink" title=".Net Framework中的委托与事件"></a>.Net Framework中的委托与事件</h2><p>尽管上面的范例很好地完成了我们想要完成的工作，但是我们不仅疑惑：为什么.Net Framework 中的事件模型和上面的不同？为什么有很多的EventArgs参数？</p>
<p>在回答上面的问题之前，我们先搞懂 .Net Framework的编码规范：</p>
<ul>
<li>委托类型的名称都应该以<code>EventHandler</code>结束。</li>
<li>委托的原型定义：有一个<code>void</code>返回值，并接受两个输入参数：一个<code>Object</code> 类型，一个 <code>EventArgs</code>类型(或继承自<code>EventArgs</code>)。</li>
<li>事件的命名为 委托去掉 <code>EventHandler</code>之后剩余的部分。</li>
<li>继承自<code>EventArgs</code>的类型应该以<code>EventArgs</code>结尾。</li>
</ul>
<p>再做一下说明：</p>
<ol>
<li>委托声明原型中的<code>Object</code>类型的参数代表了<code>Subject</code>，也就是监视对象，在本例中是 <code>Heater</code>(热水器)。回调函数(比如<code>Alarm</code>的<code>MakeAlert</code>)可以通过它访问触发事件的对象(<code>Heater</code>)。</li>
<li><code>EventArgs</code> 对象包含了<code>Observer</code>所感兴趣的数据，在本例中是<code>temperature</code>。</li>
</ol>
<p><strong>上面这些其实不仅仅是为了编码规范而已，这样也使得程序有更大的灵活性。</strong>比如说，如果我们不光想获得热水器的温度，还想在<code>Observer</code>端(警报器或者显示器)方法中获得它的生产日期、型号、价格，那么委托和方法的声明都会变得很麻烦，而如果我们将热水器的引用传给警报器的方法，就可以在方法中直接访问热水器了。</p>
<p>现在我们改写之前的范例，让它符合 .Net Framework 的规范：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line">using System;</div><div class="line">using System.Collections.Generic;</div><div class="line">using System.Text;</div><div class="line">namespace Delegate &#123;</div><div class="line">    // 热水器</div><div class="line">    public class Heater &#123;</div><div class="line">       private int temperature;</div><div class="line">       public string type = &quot;RealFire 001&quot;;       // 添加型号作为演示</div><div class="line">       public string area = &quot;China Xian&quot;;         // 添加产地作为演示</div><div class="line">       //声明委托</div><div class="line">       public delegate void BoiledEventHandler(Object sender, BoiledEventArgs e);</div><div class="line">       public event BoiledEventHandler Boiled; //声明事件</div><div class="line">       // 定义BoiledEventArgs类，传递给Observer所感兴趣的信息</div><div class="line">       public class BoiledEventArgs : EventArgs &#123;</div><div class="line">           public readonly int temperature;</div><div class="line">           public BoiledEventArgs(int temperature) &#123;</div><div class="line">              this.temperature = temperature;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       // 可以供继承自 Heater 的类重写，以便继承类拒绝其他对象对它的监视</div><div class="line">       protected virtual void OnBoiled(BoiledEventArgs e) &#123;</div><div class="line">           if (Boiled != null) &#123; // 如果有对象注册</div><div class="line">              Boiled(this, e);  // 调用所有注册对象的方法</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       // 烧水。</div><div class="line">       public void BoilWater() &#123;</div><div class="line">           for (int i = 0; i &lt;= 100; i++) &#123;</div><div class="line">              temperature = i;</div><div class="line">              if (temperature &gt; 95) &#123;</div><div class="line">                  //建立BoiledEventArgs 对象。</div><div class="line">                  BoiledEventArgs e = new BoiledEventArgs(temperature);</div><div class="line">                  OnBoiled(e);  // 调用 OnBolied方法</div><div class="line">              &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">    // 警报器</div><div class="line">    public class Alarm &#123;</div><div class="line">       public void MakeAlert(Object sender, Heater.BoiledEventArgs e) &#123;</div><div class="line">           Heater heater = (Heater)sender;     //这里是不是很熟悉呢？</div><div class="line">           //访问 sender 中的公共字段</div><div class="line">           Console.WriteLine(&quot;Alarm：&#123;0&#125; - &#123;1&#125;: &quot;, heater.area, heater.type);</div><div class="line">           Console.WriteLine(&quot;Alarm: 嘀嘀嘀，水已经 &#123;0&#125; 度了：&quot;, e.temperature);</div><div class="line">           Console.WriteLine();</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">    // 显示器</div><div class="line">    public class Display &#123;</div><div class="line">       public static void ShowMsg(Object sender, Heater.BoiledEventArgs e) &#123;   //静态方法</div><div class="line">           Heater heater = (Heater)sender;</div><div class="line">           Console.WriteLine(&quot;Display：&#123;0&#125; - &#123;1&#125;: &quot;, heater.area, heater.type);</div><div class="line">           Console.WriteLine(&quot;Display：水快烧开了，当前温度：&#123;0&#125;度。&quot;, e.temperature);</div><div class="line">           Console.WriteLine();</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">    class Program &#123;</div><div class="line">       static void Main() &#123;</div><div class="line">           Heater heater = new Heater();</div><div class="line">           Alarm alarm = new Alarm();</div><div class="line">           heater.Boiled += alarm.MakeAlert;   //注册方法</div><div class="line">           heater.Boiled += (new Alarm()).MakeAlert;      //给匿名对象注册方法</div><div class="line">           heater.Boiled += new Heater.BoiledEventHandler(alarm.MakeAlert);    //也可以这么注册</div><div class="line">           heater.Boiled += Display.ShowMsg;       //注册静态方法</div><div class="line">           heater.BoilWater();   //烧水，会自动调用注册过对象的方法</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Alarm：China Xian - RealFire 001:</div><div class="line">Alarm: 嘀嘀嘀，水已经 96 度了：</div><div class="line">Alarm：China Xian - RealFire 001:</div><div class="line">Alarm: 嘀嘀嘀，水已经 96 度了：</div><div class="line">Alarm：China Xian - RealFire 001:</div><div class="line">Alarm: 嘀嘀嘀，水已经 96 度了：</div><div class="line">Display：China Xian - RealFire 001:</div><div class="line">Display：水快烧开了，当前温度：96度。</div><div class="line">// 省略 ...</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中我首先通过一个<code>GreetingPeople</code>的小程序向大家介绍了委托的概念、委托用来做什么，随后又引出了事件，接着对委托与事件所产生的中间代码做了粗略的讲述。</p>
<p>在第二个稍微复杂点的热水器的范例中，我向大家简要介绍了 <code>Observer</code>设计模式，并通过实现这个范例完成了该模式，随后讲述了.Net Framework中委托、事件的实现方式。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>文章转载自<a href="http://www.tracefact.net/csharp-programming/delegates-and-events-in-csharp.aspx" target="_blank" rel="external">张子阳 -《.NET之美》</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;delegate&lt;/code&gt; 和 &lt;code&gt;event&lt;/code&gt;在 .Net Framework中的应用非常广泛，然而，较好地理解委托和事件对很多接触C#时间不长的人来说并不容易。本文中，我将通过两个范例由浅入深地讲述什么是委托、为什么要使用委托、事件的由来、.Net Framework中的委托和事件、委托和事件对Observer设计模式的意义，对它们的中间代码也做了讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
    
      <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>命令行、终端和 Git 的代理设置</title>
    <link href="http://yoursite.com/2017/10/31/Proxy%20setting%20of%20CMD:Terminal/"/>
    <id>http://yoursite.com/2017/10/31/Proxy setting of CMD:Terminal/</id>
    <published>2017-10-31T08:19:58.131Z</published>
    <updated>2017-10-31T08:19:58.131Z</updated>
    
    <content type="html"><![CDATA[<p>本文整理了 Windows 命令行 和 Linux 终端以及 Git 中设置代理的命令。以本地 HTTP/HTTPS 代理 <code>127.0.0.1:8118</code> 和 SOCKS5 代理 <code>127.0.0.1:1080</code> 为例。</p>
<a id="more"></a>
<h2 id="Windows-命令行代理设置"><a href="#Windows-命令行代理设置" class="headerlink" title="Windows 命令行代理设置"></a>Windows 命令行代理设置</h2><p>HTTP 代理设置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set http_proxy=http://127.0.0.1:8118</div><div class="line">set https_proxy=http://127.0.0.1:8118</div></pre></td></tr></table></figure>
<p>SOCKS5 代理设置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set http_proxy=socks5://127.0.0.1:1080</div><div class="line">set https_proxy=socks5://127.0.0.1:1080</div></pre></td></tr></table></figure>
<p>可以通过 <code>echo %http_proxy%</code> 命令查看是否设置成功。</p>
<p>取消代理设置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set http_proxy=</div><div class="line">set https_proxy=</div></pre></td></tr></table></figure>
<h2 id="Linux-终端代理设置"><a href="#Linux-终端代理设置" class="headerlink" title="Linux 终端代理设置"></a>Linux 终端代理设置</h2><h3 id="临时代理设置"><a href="#临时代理设置" class="headerlink" title="临时代理设置"></a>临时代理设置</h3><p>Linux 终端设置 HTTP 代理（只对当前终端有效）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> http_proxy=http://127.0.0.1:8118</span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> https_proxy=http://127.0.0.1:8118</span></div></pre></td></tr></table></figure>
<p>Linux 中设置 SOCKS5 代理（只对当前终端有效）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> http_proxy=socks5://127.0.0.1:1080</span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> https_proxy=socks5://127.0.0.1:1080</span></div></pre></td></tr></table></figure>
<p>设置终端中的 wget、curl 等都走 SOCKS5 代理（只对当前终端有效）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">export</span> ALL_PROXY=socks5://127.0.0.1:1080</span></div></pre></td></tr></table></figure>
<p>Linux 终端中取消代理设置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> http_proxy</span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> https_proxy</span></div><div class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">unset</span> ALL_RPOXY</span></div></pre></td></tr></table></figure>
<h3 id="永久代理设置"><a href="#永久代理设置" class="headerlink" title="永久代理设置"></a>永久代理设置</h3><p>将代理命令写入配置文件 <code>~/.profile</code> 或 <code>~/.bashrc</code> 或 <code>~/.zshrc</code> 中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> HTTP 代理设置</span></div><div class="line">export http_proxy=http://127.0.0.1:8118</div><div class="line">export https_proxy=http://127.0.0.1:8118</div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> SOCKS5 代理设置</span></div><div class="line">export http_proxy=socks5://127.0.0.1:1080</div><div class="line">export https_proxy=socks5://127.0.0.1:1080</div></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 强制终端中的 wget、curl 等都走 SOCKS5 代理</span></div><div class="line">export ALL_PROXY=socks5://127.0.0.1:1080</div></pre></td></tr></table></figure>
<p>或简化操作</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alias pc="export ALL_PROXY=socks5://127.0.0.1:1080; echo 'Proxy on';"</div></pre></td></tr></table></figure>
<h2 id="Git-设置代理"><a href="#Git-设置代理" class="headerlink" title="Git 设置代理"></a>Git 设置代理</h2><p>代理格式 <code>[protocol://][user[:password]@]proxyhost[:port]</code><br>参考 <a href="https://git-scm.com/docs/git-config" target="_blank" rel="external">https://git-scm.com/docs/git-config</a></p>
<p>设置 HTTP 代理：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global http.proxy http://127.0.0.1:8118</div><div class="line">git config --global https.proxy http://127.0.0.1:8118</div></pre></td></tr></table></figure>
<p>设置 SOCKS5 代理：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global http.proxy socks5://127.0.0.1:1080</div><div class="line">git config --global https.proxy socks5://127.0.0.1:1080</div></pre></td></tr></table></figure>
<p>Git 取消代理设置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global --unset http.proxy</div><div class="line">git config --global --unset https.proxy</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文整理了 Windows 命令行 和 Linux 终端以及 Git 中设置代理的命令。以本地 HTTP/HTTPS 代理 &lt;code&gt;127.0.0.1:8118&lt;/code&gt; 和 SOCKS5 代理 &lt;code&gt;127.0.0.1:1080&lt;/code&gt; 为例。&lt;/p&gt;
    
    </summary>
    
      <category term="Tutorial" scheme="http://yoursite.com/categories/Tutorial/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
      <category term="Terminal" scheme="http://yoursite.com/tags/Terminal/"/>
    
  </entry>
  
  <entry>
    <title>初步了解 Swift 中的可选类型和方法函数</title>
    <link href="http://yoursite.com/2017/10/25/Optional%20types%20and%20method%20functions%20in%20Swift/"/>
    <id>http://yoursite.com/2017/10/25/Optional types and method functions in Swift/</id>
    <published>2017-10-25T09:19:23.069Z</published>
    <updated>2017-10-25T10:17:38.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可选类型和解包"><a href="#可选类型和解包" class="headerlink" title="可选类型和解包"></a>可选类型和解包</h2><p>Swift中，在数组的方括号内必须写上类型，或者在<code>Array</code>后面的尖括号<code>&lt;&gt;</code>内写上类型。</p>
<p>对于字典而言，你一共需要提供两个类型，一个用于键，而另一个用于值。</p>
<p>Swift要求所有的变量和常量都必须有值。你可以在声明它们的时候给它们指定一个值，也可以通过<code>init</code>方法给它们分配值。</p>
<a id="more"></a>
<p>有时，你需要一个变量可以没有值，这种情况，你需要将变量声明为可选型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> checklistToEdit: <span class="type">Checklist</span>?</div></pre></td></tr></table></figure>
<p>可是你不能直接使用这种类型的变量，你必须在使用它们之前，侦测一下其中是否有值，这个行为就叫做可选型解包：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> checklist = checklistToEdit &#123;</div><div class="line">  	<span class="comment">// “checklist” now contains the real object</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  	<span class="comment">// the optional was nil</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面例子中的变量<code>age</code>就是一个可选型，因为没有任何保证说字典中存在一个名为”Jony Ive”的键，所以<code>age</code>的类型是<code>Int?</code>，而不是<code>Int</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> age = dict[<span class="string">"Jony Ive"</span>] &#123;</div><div class="line"><span class="comment">// 使用age变量</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你100%的确定字典中存在一个叫做”Jony Ive”的键的话，那么你就可以对<code>age</code>变量进行强制解包：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> age = dict[<span class="string">"Jony Ive"</span>]!</div></pre></td></tr></table></figure>
<p>你使用感叹号<code>!</code>来通知Swift，“这个可选型不会为nil，我用我的名誉打赌！”，当然，如果你错了的话，这个变量的值为<code>nil</code>，那么app就会挂掉，你也就名誉扫地了，所以你在使用强制解包的时候一定要小心。</p>
<p>另一种稍微安全点的强制解包方式叫做可选型链接。例如，下面的语句会在<code>navigationController</code>为<code>nil</code>时把app挂掉。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">navigationController!.delegate = <span class="keyword">self</span></div></pre></td></tr></table></figure>
<p>但是像这样做则不会把app挂掉：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">navigationController?.delegate = <span class="keyword">self</span></div></pre></td></tr></table></figure>
<p>位于问号后面的任何东西，都会在<code>navigationController</code>为<code>nil</code>时把它忽视掉。这个使用问号强制解包的语句等价于下面的语句：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> navigationController != <span class="literal">nil</span> &#123;</div><div class="line">  	navigationController!.delegate = <span class="keyword">self</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在声明可选型的时候，也可以用感叹号来代替问号，这样就是一个隐式解包可选型了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> dataModel: <span class="type">DataModel</span>!</div></pre></td></tr></table></figure>
<p>这样的变量会带来潜在的危险，因为你可以如同使用常规变量那样直接使用它，并不需要先解包。一旦如果它的值为空，那么app就挂了。而当使用的常规变量为空时，编译器则会提示你该怎么做。</p>
<p>可选型平时被包裹起来，以避免app崩溃，但是使用了感叹号以后，就解除了可选型的安全级别。</p>
<p>然而，有时使用<strong>隐式解包可选型</strong>比使用<strong>可选型</strong>要方便一些。当你无法给一个变量初始值，也无法用<code>init</code>方法对其初始化的时候，你就会需要到这种隐式解包可选型。</p>
<p>如果你给了一个变量一个值后，就不应该再使它为<code>nil</code>，如果一个变量可以从有值变为<code>nil</code>，那么你最好还是使用用问号声明的可选型。</p>
<h2 id="方法与函数（Methods-and-functions）"><a href="#方法与函数（Methods-and-functions）" class="headerlink" title="方法与函数（Methods and functions）"></a>方法与函数（Methods and functions）</h2><p>有这样的一种对象，它是所有app的基础组成部分，同时具有数据和功能。实例变量及常量提供数据，方法提供功能。</p>
<h3 id="方法的返回值"><a href="#方法的返回值" class="headerlink" title="方法的返回值"></a>方法的返回值</h3><p>当你调用一个方法，app就会跳转到方法中，逐条的执行其中的语句，当方法中最后一条语句被执行完毕后，app就会会到之前离开的地方：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> result = performUselessCalculation(<span class="number">314</span>)</div><div class="line"><span class="built_in">print</span>(result)</div><div class="line">...</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">performUselessCalculation</span><span class="params">(<span class="number">_</span> a: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">var</span> b = <span class="type">Int</span>(arc4random_uniform(<span class="number">100</span>))</div><div class="line">    <span class="keyword">var</span> <span class="built_in">c</span> = a / <span class="number">2</span></div><div class="line">    <span class="keyword">return</span> (a + b) * <span class="built_in">c</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方法经常会返回一个值给调用者，比如一个计算结果或者从一个集合中找到的一个对象。返回值的类型会写在<code>-&gt;</code>符号的后面。在上面的例子中，返回值的类型是<code>Int</code>。如果不存在<code>-&gt;</code>这个符号，那么就是说这个方法不返回任何值。</p>
<h3 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h3><p>方法就是属于某一特定对象的函数，Swift中也存在独立的函数，比如<code>print()</code>或者<code>arc4random_uniform()</code>。</p>
<p>函数和方法的工作原理一样，一个可重复使用的功能块，但是函数不属于任何对象。像这种函数也被称为自由函数或者全局函数。</p>
<p>下面是一些关于方法的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个方法没有返回值及参数的方法</span></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span></div><div class="line"></div><div class="line"><span class="comment">// 这个方法有一个slider参数，但是一样没有返回值</span></div><div class="line"><span class="comment">// 关键字@IBAction意味着这个方法可以被连接到界面建造器的控件上</span></div><div class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">sliderMoved</span><span class="params">(<span class="number">_</span> slider: UISlider)</span></span></div><div class="line"></div><div class="line"><span class="comment">// 这个方法没有参数，但是有一个Int型的返回值</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">countUncheckedItems</span><span class="params">()</span></span> -&gt; <span class="type">Int</span></div><div class="line"></div><div class="line"><span class="comment">// 这个方法有两个参数，cell和item，但是没有返回值</span></div><div class="line"><span class="comment">// 注意一下，第一个参数有一个外部名称for，而第二个参数有一个外部名称with</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">configureCheckmarkFor</span><span class="params">(<span class="keyword">for</span> cell: UITableViewCell,</span></span></div><div class="line"><span class="function"><span class="params">                           with item: ChecklistItem)</span></span></div><div class="line"></div><div class="line"><span class="comment">// 这个方法有两个参数, tableView和section. 并且有一个Int型的返回值。</span></div><div class="line"><span class="comment">// 第一个参数前的下划线代表这个参数没有外部名称。</span></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView,</span></span></div><div class="line"><span class="function"><span class="params">                        numberOfRowsInSection section: Int)</span></span> -&gt; <span class="type">Int</span></div><div class="line"></div><div class="line"><span class="comment">// 这个方法有两个参数, tableView和indexPath.</span></div><div class="line"><span class="comment">// 问号代表它返回一个为可选型的IndexPath对象。</span></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView,</span></span></div><div class="line"><span class="function"><span class="params">                    willSelectRowAt indexPath: IndexPath)</span></span> -&gt; <span class="type">IndexPath</span>?</div></pre></td></tr></table></figure>
<p>在一个对象上调用一个方法，语法是<code>object.method(parameters)</code>。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Calling a method on the lists object:</span></div><div class="line">lists.append(checklist)</div><div class="line"><span class="comment">// Calling a method with more than one parameter:</span></div><div class="line">tableView.insertRows(at: indexPaths, with: .fade)</div></pre></td></tr></table></figure>
<p>你可以把调用方法想象为从一个对象向另一个对象传递消息：“嗨 lists，我从checklist对象中向你发送了append的消息。”</p>
<p>你调用消息所属的对象被称为消息的接收者。</p>
<p>从同一个对象中调用方法非常常见，下面的例子中，<code>loadChecklists()</code>调用了<code>sortChecklists()</code>。它们都是<code>DataModel</code>对象中的成员：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataModel</span> </span>&#123;</div><div class="line">  	<span class="function"><span class="keyword">func</span> <span class="title">loadChecklists</span><span class="params">()</span></span> &#123;</div><div class="line">        ...</div><div class="line">        sortChecklists()</div><div class="line">  	&#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sortChecklists</span><span class="params">()</span></span> &#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有时你会写为下面这个样子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadChecklists</span><span class="params">()</span></span> &#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">self</span>.sortChecklists()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关键字<code>self</code>清晰的表明了<code>DataModel</code>对象自己是这个消息的接受者。</p>
<blockquote>
<p>⚠️：在我们的课程中，调用方法的时候，我省略了self关键字，因为并不是必须要这样做。Object-C开发者会非常乐意在每个地方都写上self，所以你也许会见到它在Swift中也被大量使用。到底写与不写，这是程序员间可以引发战争的一个话题，但是无论如何，app并不是太关心这点。</p>
</blockquote>
<p>在一个方法的内部，你也可以使用self关键字来引用这个对象自己：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@IBAction</span> <span class="function"><span class="keyword">func</span> <span class="title">cancel</span><span class="params">()</span></span> &#123;</div><div class="line">	delegate?.itemDetailViewControllerDidCancel(<span class="keyword">self</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里<code>cancel()</code>方法将对象自身的引用发送给<code>delegate</code>，所以<code>delegate</code>知道谁发送了这个<code>itemDetailViewControllerDidCancel()</code>消息。</p>
<p>同时注意一下这里的可选型链接。这个<code>delegate</code>属性是个可选型，所以它可以为nil。在调用方法前使用一个问号来确保<code>delegate</code>为<code>nil</code>时，app不会挂掉。</p>
<h3 id="方法的参数"><a href="#方法的参数" class="headerlink" title="方法的参数"></a>方法的参数</h3><p>方法经常会具有一个或多个参数，所以你可以让它们接收不同数据源上的数据。一个被限定了数据源的方法，就不会非常有价值。例如下面的<code>sumValuesFormArray()</code>方法，它没有参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> numbers = [<span class="type">Int</span>]()</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sunValuesFromArray</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">var</span> total = <span class="number">0</span></div><div class="line">        <span class="keyword">for</span> number <span class="keyword">in</span> numbers &#123;</div><div class="line">            total += number</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> total</div><div class="line"> 	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，<code>numbers</code>是一个实例变量。方法<code>sumValuesFromArray()</code>被这个实例变量绑定死了，如果这个变量不存在，那么这个方法就没用了。</p>
<p>假设你在这个app中添加了第二数组，也想要应用上面的计算，方法之一是把这个方法复制一遍，重新命名为一个新的方法来处理这个新的数组。这样做确实可行，但是者看起来不那么聪明。</p>
<p>另一个好一点的选择是，给这个方法一个参数，使得你可以传送任何你想要计算的数组，这样，这个方法就从实例变量中解放出来了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumValues</span><span class="params">(from array: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">var</span> total = <span class="number">0</span></div><div class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> array &#123;</div><div class="line">    	total += number</div><div class="line">    &#125;</div><div class="line">  	<span class="keyword">return</span> total</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在你可以用任何整数型的数组作为它的参数了。</p>
<blockquote>
<p>这并不是说方法不应该使用实例变量，只是说你想要一个方法的应用更加广泛，那么给它一个参数是个很好的选择。</p>
</blockquote>
<p>方法的参数经常会有两个名字，一个<strong>外部名称</strong>，一个<strong>内部名称</strong>，例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">downloadImage</span><span class="params">(<span class="keyword">for</span> searchResult: SearchResult,withTimeout timeout: TimeInterval,andPlaceOn button: UIButton)</span></span> &#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法有三个参数：<code>searchResult</code>，<code>timeout</code>和<code>button</code>。这些是<strong>内部名称</strong>，你在方法的<strong>内部</strong>用这些名称来调用参数。</p>
<p><strong>方法的外部名称是方法名称的一部分</strong>。所以这个方法的全名是<code>downloadImage(for,withTimeout,andPlaceOn)</code>，Swift中的方法名称经常会特别的长。</p>
<p>调用这个方法的时候，你需要使用外部名称：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">downloadImage(<span class="keyword">for</span>:result,withTimeout:<span class="number">10</span>,andPlaceButton)</div></pre></td></tr></table></figure>
<p>有时，你会看到一个方法它的第一个参数没有外部名称，取而代之的是一个下划线：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">tableView</span><span class="params">(<span class="number">_</span> tableView: UITableView,numberOfRowsInSection section: Int)</span></span>-&gt; <span class="type">Int</span></div></pre></td></tr></table></figure>
<p>这种情况经常出现在委托方法中，它是Object-C的遗留物，第一个参数的内部和外部名称都会被包含在方法名称中，比如在Object-C中<code>downloadImage()</code>方法的全名会是<code>downloadImageForSearchResult</code>。像这样的命名方式，以后会非常少见。</p>
<p>如果是在Object-C中，这个方法的名称会是<code>tableViewTableVIew</code>，非常古怪是吧，而Swift中，以下划线代替外部名称时，方法名称中就可以省略这个参数的外部名称，在Swift中，这个方法的全名是<code>tableView(numberOfRowsInSection)</code>。这样是不是容易明白多了？Swift在对方法命名时更加灵活，但它还是会保留一些旧的惯例。</p>
<h2 id="循环和判断"><a href="#循环和判断" class="headerlink" title="循环和判断"></a>循环和判断</h2><p>在一个方法的内部，你可以做以下事情：</p>
<ul>
<li><p>创建局部变量或者常量</p>
</li>
<li><p>进行基本的数学运算，比如加减乘除</p>
</li>
<li><p>将一个新的值放入变量（局部变量或实例变量）</p>
</li>
<li><p>调用其他方法</p>
</li>
<li><p>使用<code>if</code>或者<code>switch</code>作出判断</p>
</li>
<li><p>用<code>for</code>或者<code>while</code>进行循环处理</p>
</li>
<li><p>返回一个值给调用者</p>
</li>
</ul>
<p>让我们来看看<code>if</code>和<code>for</code>语句的更多细节。</p>
<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a><code>if</code>语句</h4><p><code>if</code>语句的基本结构是这个样子的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="built_in">count</span> == <span class="number">0</span> &#123;</div><div class="line">	text = <span class="string">"No Items"</span></div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">count</span> == <span class="number">1</span> &#123;</div><div class="line">	text = <span class="string">"1 Item"</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">	text = <span class="string">"\(count) Items"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>if</code>后面的表达式称之为条件。如果条件为真，那么<code>if</code>后面花括号内的语句会被执行。如果没有一个条件为真，那么最后一个<code>else</code>后面的花括号内的语句会被执行。</p>
<p>通过使用比较运算符来对两个值进行比较：</p>
<ul>
<li><p><code>==</code> 等于</p>
</li>
<li><p><code>!=</code> 不等于</p>
</li>
<li><code>&lt;</code> 小于</li>
<li><code>&lt;=</code> 小于等于</li>
<li><code>&gt;</code> 大于</li>
<li><code>&gt;=</code> 大于等于</li>
</ul>
<p>使用等于操作时，被比较的两个对象仅在相等时返回<code>true</code>，比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="string">"Hello,world"</span></div><div class="line"><span class="keyword">let</span> b = <span class="string">"Hello,"</span> + <span class="string">"world"</span></div><div class="line"><span class="built_in">print</span>(a == b) <span class="comment">//打印结果为true</span></div></pre></td></tr></table></figure>
<p>这个和Object-C有所不同，在Object-C中，必须两个对象是内存中的同一个实例，才会返回为<code>true</code>。而Swift中的<code>==</code>操作，仅仅是比较对象的值，而不管它在内存中是不是同一个对象，如果在Swift中像做这个操作的话，需要使用运算符 <code>===</code>，三个等号。</p>
<p>你还可以使用逻辑操作符来连接两个表达式：</p>
<ul>
<li><p><code>&amp;&amp;</code> 与操作，<code>a &amp;&amp; b</code>必须在<code>a</code>和<code>b</code>都为<code>true</code>时才返回<code>true</code></p>
</li>
<li><p><code>||</code> 或操作符，<code>a || b</code>当<code>a</code>，<code>b</code>其中之一为<code>true</code>时，返回`true``</p>
</li>
<li><p><code>`！</code> 逻辑非操作符，它的作用是将原本的<code>true</code>转为<code>false</code>，原本的<code>false</code>转为<code>true</code>。</p>
<blockquote>
<p>不要和可选型弄混了，逻辑非操作符出现在对象的前面，而可选型的感叹号出现在对象的后面</p>
</blockquote>
</li>
</ul>
<p>可以使用括号<code>()</code>来对表达式分组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((this &amp;&amp; that) || (such &amp;&amp; so)) &amp;&amp; !other &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它读作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ((this and that) or (such and so)) and not other &#123;</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了看起来更加清晰一些，我们写的有层次一点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (</div><div class="line">  (this and that)</div><div class="line">  or</div><div class="line">  (such and so)</div><div class="line">)</div><div class="line">and</div><div class="line">  (not other)</div></pre></td></tr></table></figure>
<h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a><code>switch</code>语句</h4><p>当然，你弄的越复杂，越难记清楚自己在做什么！</p>
<p>Swift中还有一种非常强大的结构，可以用来做出判断，那就是<code>switch</code>语句：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> condition &#123;</div><div class="line">    <span class="keyword">case</span> value1:</div><div class="line">      	<span class="comment">//语句</span></div><div class="line">    <span class="keyword">case</span> value2:</div><div class="line">      	<span class="comment">//语句</span></div><div class="line">    <span class="keyword">case</span> value3:</div><div class="line">      	<span class="comment">//语句</span></div><div class="line">    <span class="keyword">default</span>:</div><div class="line">    	<span class="comment">//语句</span></div></pre></td></tr></table></figure>
<p>它的效果和多个<code>if else</code>的效果是一致的，上面的代码等同于：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> condition == value1 &#123;</div><div class="line">  	<span class="comment">//语句</span></div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition == value2 &#123;</div><div class="line">  	<span class="comment">//语句</span></div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition == value3 &#123;</div><div class="line">  	<span class="comment">//语句</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">//语句</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相较之下，<code>switch</code>在这种情况中更加便利，而且意思清晰。而且Swift版的<code>switch</code>比Object-C版的更加强大。例如，你可以使用区间范围：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> difference &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">      	title = <span class="string">"Perfect!"</span></div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>..&lt;<span class="number">5</span>:</div><div class="line">      	title = <span class="string">"You almost had it!"</span></div><div class="line">    <span class="keyword">case</span> <span class="number">5</span>..&lt;<span class="number">10</span>:</div><div class="line">      	title = <span class="string">"Pretty good!"</span></div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      	title = <span class="string">"Not even close..."</span></div></pre></td></tr></table></figure>
<p>这里的<code>..&lt;</code>是半开区间操作符。它可以创建两个值之间的区间，其中的值都是不重复的，半开区间<code>1..&lt;5</code>等价于闭区间<code>1...4</code>。</p>
<p>有时你会看到下面这个样子的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">()</span></span> &#123;</div><div class="line">  	<span class="keyword">if</span> condition1 &#123;</div><div class="line">    	<span class="keyword">if</span> condition2 &#123;</div><div class="line">      		<span class="keyword">if</span> condition3 &#123;</div><div class="line">        		<span class="comment">//语句</span></div><div class="line">      		&#125; <span class="keyword">else</span> &#123;</div><div class="line">        	<span class="comment">//语句</span></div><div class="line">     	&#125;</div><div class="line">  	&#125; <span class="keyword">else</span> &#123;</div><div class="line">  		<span class="comment">//语句</span></div><div class="line"> 		&#125; <span class="keyword">else</span> &#123;</div><div class="line">  			<span class="comment">//语句</span></div><div class="line"> 		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种代码非常难读，我喜欢将它们重构为下面这个样子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="keyword">if</span> !condition1 &#123;</div><div class="line">	<span class="comment">//语句</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> !condition2 &#123;</div><div class="line">	<span class="comment">//语句</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> !condition3 &#123;</div><div class="line">    <span class="comment">//语句</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">	<span class="comment">//语句</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两段代码的作用其实是一样的，但是后一种更加容易理解。（注意一下，第二种写法中使用了<code>！</code>逻辑非来转换了表达式的意思）</p>
<p>Swift中有一种特殊的语句，<code>guard</code>来帮助你处理这种复杂的情况，用<code>guard</code>重写一下上面的方法就是：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">guard</span> condition1 <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//语句</span></div><div class="line">        <span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">    <span class="keyword">guard</span> condition21 <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//语句</span></div><div class="line">        <span class="keyword">return</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure>
<p>你要自己尝试这些方法，比较看看哪种可读性最好，哪种看起来最好，这样慢慢的你就会很有经验了。</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p><code>for</code>循环</p>
<p>你之前已经见识过了，如何用<code>for in</code>来历遍一个数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items &#123;</div><div class="line">    <span class="keyword">if</span> !item.checked &#123;</div><div class="line">    	<span class="built_in">count</span> += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也可以写作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items <span class="keyword">where</span> !item.checked &#123;</div><div class="line">  	<span class="built_in">count</span> += <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>for in</code>中的语句会对每个<code>items</code>数组中的对象执行一遍。</p>
<p>注意一下，变量<code>item</code>的仅在<code>for</code>语句中有效，你不能在外面引用它，它的生命期比局部变量还要短。</p>
<p>有些语言，也包括Swift 2，中的<code>for</code>语句是这个样子的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i &#123;</div><div class="line">	<span class="built_in">print</span>(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当你运行这个代码，会得到如下结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<p>然而，在Swift 3种，这种<code>for</code>循环已经被抛弃了，取而代之的是，你可以直接使用区间范围，就像下面这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ... <span class="number">4</span> &#123;</div><div class="line">	<span class="built_in">print</span>(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>顺便说一下，也可写作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">0</span>,to: <span class="number">5</span>,by: <span class="number">1</span>) &#123;</div><div class="line">	<span class="built_in">print</span>(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>stride</code>函数创建了一个专门的对象来代表从1到5，每次增加1。如果你只想要偶数，你可以把<code>by</code>参数改为2。如果你给<code>by</code>参数一个负数的话，那么<code>stride</code>就可以实现倒着数的功能。</p>
<p><code>while</code>语句</p>
<p><code>for</code>语句并不是唯一的执行循环的语句，另一个非常强大的循环结构就是<code>while</code>语句：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> something <span class="keyword">is</span> <span class="literal">true</span> &#123;</div><div class="line">	<span class="comment">//语句</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>while语句会一直保持循环，知道条件为false为止。还可以使用下面这种形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">repeat</span> &#123;</div><div class="line"> 	<span class="comment">//语句</span></div><div class="line">&#125; <span class="keyword">while</span> something <span class="keyword">is</span> <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>在这种情况中，条件是在语句执行后才判断的，所以括号内的语句至少也会被执行一次。</p>
<p>你可以使用<code>while</code>语句重写一下循环<code>Checklists</code>中的对象：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></div><div class="line"><span class="keyword">var</span> i = <span class="number">0</span></div><div class="line"><span class="keyword">while</span> i &lt; items.<span class="built_in">count</span> &#123;</div><div class="line">   <span class="keyword">let</span> item = items[i]</div><div class="line">   <span class="keyword">if</span> !item.checked &#123;</div><div class="line">     <span class="built_in">count</span> += <span class="number">1</span></div><div class="line">   &#125;</div><div class="line">   i += <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些循环结构的作用大致相同，只是看起来有些不一样。每一种都可以使你重复执行一段语句，直到条件不符合为止。</p>
<p>然而，使用<code>while</code>会比<code>for in</code>要看起来复杂一些，所以大多数时候，我们都会使用<code>for in</code>。</p>
<p>使用<code>for in</code>、<code>while</code>、<code>repeat</code>并没有什么不同，只是可读性上有所区别。</p>
<blockquote>
<p>⚠️：上面例子中的<code>item.count</code>和<code>count</code>是两种不同的东西，只是名字一样。<code>item.count</code>中的<code>count</code>是数组<code>items</code>中的属性用于返回数组中元素的个数；后面的一个<code>count</code>是一个局部变量，用于对没有激活对勾符号的item对象计数。</p>
</blockquote>
<p>就你可以在方法中使用<code>return</code>退出方法一样，你可以使用<code>break</code>来提前退出循环：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> found = <span class="literal">false</span></div><div class="line"><span class="keyword">for</span> item <span class="keyword">in</span> array &#123;</div><div class="line">  	<span class="keyword">if</span> item == searchText &#123;</div><div class="line">    	found = <span class="literal">true</span></div><div class="line">    	<span class="keyword">break</span></div><div class="line">  	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子中，<code>for</code>语句在数组中循环，直到找到第一个与<code>searchText</code>的值相当的值后，将<code>found</code>设置为<code>true</code>，然后退出循环，不再查看数组中剩下的对象。因为你已经找到了你想要的东西，所以没有必要把整个数组都循环完毕。</p>
<p>还存在一个<code>contiue</code>语句，和<code>break</code>的作用正好相反。它的作用是立即跳到下一个迭代中，当你使用<code>contiue</code>时，你的意思就是“目前这个item已经结束了，我们去看看下一个吧！”</p>
<h4 id="其他语句"><a href="#其他语句" class="headerlink" title="其他语句"></a>其他语句</h4><p>在函数编程中，循环经常会被<code>map</code>，<code>filter</code>或者<code>reduce</code>替代。它们是一些操作集合的函数，对集合中每一个元素执行一段代码，并且返回一个新的集合作为结果。</p>
<p>例如，在数组上使用<code>filter</code>，会保留符合某些条件的元素。比如要得到未激活对勾符号的ChecklistItem对象，你可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var uncheckedItems = items.filter &#123; item in !item.checked&#125;</div></pre></td></tr></table></figure>
<p>这样写比循环看起来要简单多了。函数编程是一个非常大的话题，所以在这里我们不会展开太多。</p>
<h2 id="对象（Objects）"><a href="#对象（Objects）" class="headerlink" title="对象（Objects）"></a>对象（Objects）</h2><p>将功能和数据结合在一起的可重用单元，都是对象。</p>
<p>数据是由对象中的实例变量和实例常量组成。我们经常以对象的属性形式引用它们。功能由对象的方法提供。</p>
<p>在你的Swift程序中，你使用过已存在的对象，比如<code>String</code>，<code>Array</code>，<code>Date</code>，<code>UITableView</code>，以及你自己创建的对象。</p>
<p>定义一个新的对象，你需要一个新的Swift文件，比如MyObject.swift，并且包含一个类（<code>class</code>）。比如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</div><div class="line">  	<span class="keyword">var</span> text: <span class="type">String</span></div><div class="line">  	<span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></div><div class="line">    <span class="keyword">let</span> maximum = <span class="number">100</span></div><div class="line"> </div><div class="line">  	<span class="keyword">init</span>() &#123;</div><div class="line">    	text = <span class="string">"Hello World"</span></div><div class="line"> 	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</div><div class="line">  		<span class="comment">//语句</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>class</code>的花括号内，你添加了属性（实例变量和实例常量）和方法。</p>
<p>属性有两种类型：</p>
<ul>
<li><p>存储属性，它们通常是实例变量和实例常量。</p>
</li>
<li><p>计算属性，不存储东西，而是执行某些逻辑</p>
</li>
</ul>
<p>下面是一个关于计算属性的例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> indexOfSelectedChecklist: <span class="type">Int</span> &#123;</div><div class="line">  	<span class="keyword">get</span> &#123;</div><div class="line">    	<span class="keyword">return</span> <span class="type">UserDefaults</span>.standard().integerForKey(<span class="string">"ChecklistIndex"</span>)</div><div class="line">  	&#125;</div><div class="line"> 	<span class="keyword">set</span> &#123;</div><div class="line">      	<span class="type">UserDefaults</span>.standard().<span class="keyword">set</span>(newValue,forKey: <span class="string">"ChecklistIndex"</span>)</div><div class="line"> 	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>indexOfSelectedChecklist</code>属性并不存储一个值，取而代之的是，每次有人使用这个属性时，它执行<code>get</code>或者<code>set</code>内的代码。另一个选择是，分别写一个<code>setIndexOfSelectedChecklist()</code>和<code>getIndexOfSelectedChecklist()</code>方法，但是这样读起来不是很好。</p>
<p>关键字<code>@IBOutlet</code>的意思是，这个属性可以被界面建造器中的用户接口元素引用，比如label和button。这种属性通常都被声明为<code>weak</code>和可选型。类似的，<code>@IBAction</code>关键字被用于和用户交互时被触发的方法。</p>
<p>这里有三种类型的方法：</p>
<ol>
<li><p>实例方法</p>
</li>
<li><p>类方法</p>
</li>
<li><p><code>init</code>方法</p>
</li>
</ol>
<p>你已经知道了方法就是属于某一个对象的函数。调用这种类型的方法你首先需要一个这个对象的实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> myInstance = <span class="type">MyObject</span>()  <span class="comment">//创建一个对象的实例</span></div><div class="line">myInstance.doSomething()   <span class="comment">//调用方法</span></div></pre></td></tr></table></figure>
<p>你也可以创建一个类方法，这样就可以在没有实例的情况下使用这个方法。事实上，类方法经常被当作“工厂”方法使用，用来创建新的实例：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</div><div class="line">...</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">fun</span> <span class="title">makeObject</span>(<span class="title">text</span>: <span class="title">String</span>)-&gt; <span class="title">MyObject</span> </span>&#123;</div><div class="line">    	<span class="keyword">let</span> m = <span class="type">MyObject</span>()</div><div class="line">    	m.text = text</div><div class="line">    	<span class="keyword">return</span> m</div><div class="line">  	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> <span class="type">MyInstance</span> = <span class="type">MyObject</span>.makeObject(text: <span class="string">"Hello world"</span>)</div></pre></td></tr></table></figure>
<p><code>init</code>方法，或者叫做初始化设置，在创建一个新的对象实例的过程中被使用。你也可以使用<code>init</code>方法来取代上面的那个工厂方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> </span>&#123;</div><div class="line">...</div><div class="line">	<span class="keyword">init</span>(text: <span class="type">String</span>) &#123;</div><div class="line">    	<span class="keyword">self</span>.text = text</div><div class="line"> 	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>init</code>方法的主要目的是将对象中的实例变量填满。任何没有值的实例变量和实例常量都必须在<code>init</code>方法中被给予一个值。</p>
<p>Swift不允许变量或者常量没有值（可选型例外），并且<code>init</code>方法是你给变量或者常量赋值的最后一次机会。</p>
<p>对象可以拥有一个以上的<code>init</code>方法；具体使用哪一个要依据具体情况而定。</p>
<p>例如，一个<code>UITableViewController</code>，从故事模版中自动被读取时，使用<code>init?(coder)</code>初始化，手动从nib文件中读取时，使用<code>init(nibName,bundle)</code>初始化，或者没有从故事模版和nib文件中构造时，使用<code>init(style)</code>初始化。有时你会用到这个，而有时你会用到那个。</p>
<p>当对象不再被使用时，你可以提供一个<code>deinit</code>方法。在对象被破坏掉前调用它。</p>
<p>顺便说一下，<code>class</code>并不是Swift中唯一定义对象的方法。还存在其他类型的对象，比如<code>structs</code>和<code>enums</code>。</p>
<h2 id="协议（Protocols）"><a href="#协议（Protocols）" class="headerlink" title="协议（Protocols）"></a>协议（Protocols）</h2><p>一个协议就是一组方法名称的列表：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyProtocol</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">someMethod</span><span class="params">(value: Int)</span></span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">anotherMethod</span><span class="params">()</span></span>-&gt; <span class="type">String</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>协议就类似于工作列表。它列出了你的公司中每个具体职位的工作。</p>
<p>但是列表自己本身并不工作，它仅仅是打印出来给大家看的东西。所以你需要雇佣具体的员工来完成列表上的工作。而这些员工，就是具体的对象。</p>
<p>对象需要被指明自己需要遵守的协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span>: <span class="title">MyProtocol</span> </span>&#123;</div><div class="line"> 	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，这个对象就需要完成协议中列出的所有方法。（否则，就炒了它）</p>
<p>此时，你就可以引用这个对象，同时还有协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> m1: <span class="type">MyObject</span> = <span class="type">MyObject</span>()</div><div class="line"><span class="keyword">var</span> m2: <span class="type">MyProtocol</span> = <span class="type">MyObject</span>()</div></pre></td></tr></table></figure>
<p>对于代码中任何使用<code>m2</code>变量的部分，它是否是<code>MyObject</code>对象并不重要。<code>m2</code>类型是<code>MyProtocol</code>，不是<code>MyObject</code>。</p>
<p>所有你的代码看到的是，<code>m2</code>是某个遵守<code>MyProtocol</code>协议的对象，但是具体是什么样的对象并不重要。</p>
<p>换而言之，你并不关心你雇用的员工，是不是兼职其他工作，只要他和你需要的东西不冲突，你就可以雇佣他。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;可选类型和解包&quot;&gt;&lt;a href=&quot;#可选类型和解包&quot; class=&quot;headerlink&quot; title=&quot;可选类型和解包&quot;&gt;&lt;/a&gt;可选类型和解包&lt;/h2&gt;&lt;p&gt;Swift中，在数组的方括号内必须写上类型，或者在&lt;code&gt;Array&lt;/code&gt;后面的尖括号&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;内写上类型。&lt;/p&gt;
&lt;p&gt;对于字典而言，你一共需要提供两个类型，一个用于键，而另一个用于值。&lt;/p&gt;
&lt;p&gt;Swift要求所有的变量和常量都必须有值。你可以在声明它们的时候给它们指定一个值，也可以通过&lt;code&gt;init&lt;/code&gt;方法给它们分配值。&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
    
      <category term="Swift" scheme="http://yoursite.com/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>矩阵，向量求导法则</title>
    <link href="http://yoursite.com/2017/10/12/The%20Derivation%20formula%20of%20matrix%20and%20vector/"/>
    <id>http://yoursite.com/2017/10/12/The Derivation formula of matrix and vector/</id>
    <published>2017-10-12T14:55:37.832Z</published>
    <updated>2017-10-12T15:03:40.846Z</updated>
    
    <content type="html"><![CDATA[

	<div class="row">
    <embed src="http://files.cnblogs.com/files/leoleo/matrix_rules.pdf" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
    
    <summary type="html">
    
      

	&lt;div class=&quot;row&quot;&gt;
    &lt;embed src=&quot;http://files.cnblogs.com/files/leoleo/matrix_rules.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>C#中的abstract和virtual</title>
    <link href="http://yoursite.com/2017/10/12/The%20abstract%20and%20virtual%20in%20CSharp/"/>
    <id>http://yoursite.com/2017/10/12/The abstract and virtual in CSharp/</id>
    <published>2017-10-12T08:07:11.021Z</published>
    <updated>2017-10-12T15:01:48.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="abstract-new和override"><a href="#abstract-new和override" class="headerlink" title="abstract, new和override"></a><code>abstract</code>, <code>new</code>和<code>override</code></h2><ul>
<li>抽象（<code>abstract</code>）方法<strong>必须</strong>在抽象类中定义，且没有方法的实现。</li>
<li>基类中的抽象（<code>abstract</code>）方法<strong>必须</strong>在派生类中重写（<code>override</code>）。</li>
<li>抽象类无法创建基实例，只能继承后创建。</li>
<li>派生类中如果重新定义和基类同名的方法，使用<code>new</code>关键字。</li>
<li>派生类中如果要重写基类中同名已经实现的方法，则基类中的方法用<code>virtual</code>关键字，派生类中的同名方法用<code>override</code>关键字重写。</li>
<li><code>virtual</code>修饰的法法必须要实现。</li>
<li><code>virtual</code>和<code>abstract</code>修饰的方法必须是<code>pubulic</code>。</li>
<li><code>virtual</code>方法<strong>必须</strong>实现，<code>abstract</code>方法<strong>不一定</strong>要实现。</li>
<li><code>virtual</code>方法<strong>可以</strong>被派生类重写，<code>abstract</code>方法<strong>必须</strong>在派生类中重写。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;abstract-new和override&quot;&gt;&lt;a href=&quot;#abstract-new和override&quot; class=&quot;headerlink&quot; title=&quot;abstract, new和override&quot;&gt;&lt;/a&gt;&lt;code&gt;abstract&lt;/code&gt;,
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
    
      <category term="C#" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Scikit-learn的支持向量机（SVM）</title>
    <link href="http://yoursite.com/2017/10/05/Support%20vector%20machine%20(SVM)%20for%20scikit-learn/"/>
    <id>http://yoursite.com/2017/10/05/Support vector machine (SVM) for scikit-learn/</id>
    <published>2017-10-05T09:41:54.682Z</published>
    <updated>2017-10-05T12:25:47.053Z</updated>
    
    <content type="html"><![CDATA[<script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<p>文章排版还有问题，待修改</p>
<hr>
<p>支持向量机（SVM）是用于分类，回归和异常值检测的监督学习方法。</p>
<p>支持向量机的优点包括：</p>
<ul>
<li>在高维空间中行之有效。</li>
<li>当维数大于样本数时仍然可用。</li>
<li>在决策函数中只使用训练点的一个子集（称为支持向量），大大节省了内存开销。</li>
<li>用途广泛：决策函数中可以使用不同的<a href="http://scikit-learn.org/stable/modules/svm.html#svm-kernels" target="_blank" rel="external">核函数</a>。提供了一种通用的核，但是也可以指定自定义的核。</li>
<li>返回的分割直线满足margin最大的条件，所以是一个robust的解。</li>
<li><strong>SVM对数据点的依赖是稀疏的</strong>，只有少量支持向量对最终结果有贡献。</li>
</ul>
<p>而其劣势在于</p>
<ul>
<li>如果特征数量远大于样本数量，则表现会比较差。</li>
<li>SVM不直接提供概率估计。这个值通过五折交叉验证计算，代价比较高（见下面“跑分与概率”一节）。</li>
<li>首先SVM的优化问题比较复杂，不仅人难以理解，写起程序来也比较复杂，必须要用到Sequential minimal optimization（SMO）。</li>
<li>其次，传统的SVM只能处理线性可分的问题，并且对数据中的噪音也很敏感，因此我们必要对算法进行改造。</li>
</ul>
<p>Scikit-learn中的支持向量机同时支持密集样本向量（<code>numpy.ndarray</code>和可通过<code>numpy.asarray</code>转化的数据类型）和稀疏样本向量（任何<code>scipy.sparse</code>对象）。但是如果想用SVM对稀疏数据进行预测，则必须先在这些数据上拟合。为了优化性能，应该使用C阶（C-Ordered）<code>numpy.ndarray</code>（密集的）或<code>scipy.sparse.csr_matrix</code>（稀疏的），并指定<code>dtype=float64</code>。</p>
<a id="more"></a>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>要在数据集上进行多类别分类，可以使用<a href="http://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html#sklearn.svm.SVC" target="_blank" rel="external"><code>SVC</code></a>，<a href="http://scikit-learn.org/stable/modules/generated/sklearn.svm.NuSVC.html#sklearn.svm.NuSVC" target="_blank" rel="external"><code>NuSVC</code></a>和<a href="http://scikit-learn.org/stable/modules/generated/sklearn.svm.LinearSVC.html#sklearn.svm.LinearSVC" target="_blank" rel="external"><code>LinearSVC</code></a>这三个类。</p>
<p><img src="http://scikit-learn.org/stable/_images/sphx_glr_plot_iris_001.png" alt="sphx_glr_plot_iris_0012"></p>
<p> <code>SVC</code>和<code>NuSVC</code>两种方法类似，但是接受的参数有细微不同，而且底层的数学原理不一样（见“数学原理”一节）。另一方面，<code>LinearSVC</code>是对支持向量分类的另一种实现，使用了线性核。注意<code>LinearSVC</code>不接受关键字<code>kernel</code>，因为核被预设为是线性的。其与<code>SVC</code>和<code>NuSVC</code>相比还缺少了一些成员，如<code>support_</code>。</p>
<p>和其它分类器一样，<a href="http://scikit-learn.org/stable/modules/generated/sklearn.svm.SVC.html#sklearn.svm.SVC" target="_blank" rel="external"><code>SVC</code></a>，<a href="http://scikit-learn.org/stable/modules/generated/sklearn.svm.NuSVC.html#sklearn.svm.NuSVC" target="_blank" rel="external"><code>NuSVC</code></a>和<a href="http://scikit-learn.org/stable/modules/generated/sklearn.svm.LinearSVC.html#sklearn.svm.LinearSVC" target="_blank" rel="external"><code>LinearSVC</code></a>接受两个数组：大小为<code>[n_samples, n_features]</code>的数组X，包含训练样本；以及大小为<code>[n_samples]</code>的数组y，包含类别标签（以字符串类型或整型存储）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>X = [[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>y = [<span class="number">0</span>, <span class="number">1</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>clf = svm.SVC()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>clf.fit(X, y)  </div><div class="line">SVC(C=<span class="number">1.0</span>, cache_size=<span class="number">200</span>, class_weight=<span class="keyword">None</span>, coef0=<span class="number">0.0</span>,</div><div class="line">    decision_function_shape=<span class="keyword">None</span>, degree=<span class="number">3</span>, gamma=<span class="string">'auto'</span>, kernel=<span class="string">'rbf'</span>,</div><div class="line">    max_iter=<span class="number">-1</span>, probability=<span class="keyword">False</span>, random_state=<span class="keyword">None</span>, shrinking=<span class="keyword">True</span>,</div><div class="line">    tol=<span class="number">0.001</span>, verbose=<span class="keyword">False</span>)</div></pre></td></tr></table></figure>
<p>拟合以后就可以用得到的模型预测新值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>clf.predict([[<span class="number">2.</span>, <span class="number">2.</span>]])</div><div class="line">array([<span class="number">1</span>])</div></pre></td></tr></table></figure>
<p>SVM的决策函数依赖于训练数据的一个子集，称为支持向量。它们的一些属性可以在成员变量<code>support_vectors_</code>，<code>support_</code>和<code>n_support</code>中找到</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># get support vectors</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>clf.support_vectors_</div><div class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>],</div><div class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># get indices of support vectors</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>clf.support_ </div><div class="line">array([<span class="number">0</span>, <span class="number">1</span>]...)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># get number of support vectors for each class</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>clf.n_support_ </div><div class="line">array([<span class="number">1</span>, <span class="number">1</span>]...)</div></pre></td></tr></table></figure>
<h3 id="多类别分类"><a href="#多类别分类" class="headerlink" title="多类别分类"></a>多类别分类</h3><p><code>SVC</code>和<code>NuSVC</code>使用“一对多”方法（Knerr et al., 1990）来实现多类别分类。如果<code>n_class</code>是类别的数目，则该实现会构造<code>n_class * (n_class - 1) / 2</code>个分类器，每个分类器针对两个类别对数据进行训练。为了提供一个和其它分类器一致的接口，选项<code>decision_function_shape</code>允许调用者将所有“一对一”分类器的结果聚合进一个<code>(n_samples, n_classes)</code>的决策函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>X = [[<span class="number">0</span>], [<span class="number">1</span>], [<span class="number">2</span>], [<span class="number">3</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Y = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>clf = svm.SVC(decision_function_shape=<span class="string">'ovo'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>clf.fit(X, Y) </div><div class="line">SVC(C=<span class="number">1.0</span>, cache_size=<span class="number">200</span>, class_weight=<span class="keyword">None</span>, coef0=<span class="number">0.0</span>,</div><div class="line">    decision_function_shape=<span class="string">'ovo'</span>, degree=<span class="number">3</span>, gamma=<span class="string">'auto'</span>, kernel=<span class="string">'rbf'</span>,</div><div class="line">    max_iter=<span class="number">-1</span>, probability=<span class="keyword">False</span>, random_state=<span class="keyword">None</span>, shrinking=<span class="keyword">True</span>,</div><div class="line">    tol=<span class="number">0.001</span>, verbose=<span class="keyword">False</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dec = clf.decision_function([[<span class="number">1</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dec.shape[<span class="number">1</span>] <span class="comment"># 4 classes: 4*3/2 = 6</span></div><div class="line"><span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>clf.decision_function_shape = <span class="string">"ovr"</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dec = clf.decision_function([[<span class="number">1</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dec.shape[<span class="number">1</span>] <span class="comment"># 4 classes</span></div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<p>另一方面，<code>LinearSVC</code>实现了“一对多”分类法，因此会训练n_class个模型。如果只有两个类别，那么只会得到一个模型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>lin_clf = svm.LinearSVC()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>lin_clf.fit(X, Y) </div><div class="line">LinearSVC(C=<span class="number">1.0</span>, class_weight=<span class="keyword">None</span>, dual=<span class="keyword">True</span>, fit_intercept=<span class="keyword">True</span>,</div><div class="line">     intercept_scaling=<span class="number">1</span>, loss=<span class="string">'squared_hinge'</span>, max_iter=<span class="number">1000</span>,</div><div class="line">     multi_class=<span class="string">'ovr'</span>, penalty=<span class="string">'l2'</span>, random_state=<span class="keyword">None</span>, tol=<span class="number">0.0001</span>,</div><div class="line">     verbose=<span class="number">0</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dec = lin_clf.decision_function([[<span class="number">1</span>]])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>dec.shape[<span class="number">1</span>]</div><div class="line"><span class="number">4</span></div></pre></td></tr></table></figure>
<p>决策函数的完整描述可见“数学原理”一节。</p>
<p>需要注意的是，<code>LinearSVC</code>还实现了另一种分类策略，即所谓的多类别SVM（由Crammer和Singer提出）。通过指定<code>multi_class=&#39;crammer_singer&#39;</code>，可以使用该方法。它得到的结果总是一致的，但是一对多分类法并不能保证这一点。然而在实际应用中，还是一对多分类法用的更多，因为通常来讲该方法得到的结果变化不会太大（mostly similar），而且用的时间显著的短。</p>
<p>一对多<code>LinearSVC</code>得到的属性中，<code>coef_</code>是<code>n_class * n_features</code>维矩阵，而<code>intercept_</code>是<code>n_class * 1</code>维的。系数中的每一行都对应于n_class个“一对多”分类器中的一个（截距也是类似），按照每个与其它类别进行比较的类别顺序排序（in the order of the “one” class）。</p>
<p>而在“一对一”<code>SVC</code>中，属性的格式略微有些复杂难懂。在有线性核的情况下，<code>coef_</code>和<code>intercept_</code>的格式与上面所述<code>LinearSVC</code>的类似，只不过<code>coef</code>的大小为<code>[n_class * (n_class - 1) / 2, n_features]</code>（对应于二元分类器的个数）。类别0到n的顺序是“0 vs 1”, “0 vs 2” , … “0 vs n”, “1 vs 2”, “1 vs 3”, “1 vs n”, . . . “n-1 vs n”。</p>
<p><code>dual_coef</code>的大小是[n_class-1, n_SV]，不过格式有些难以描述。列对应于<code>n_class * (n_class - 1) / 2</code>个“一对一”分类器中出现的支持向量。每个支持向量被用于<code>n_class - 1</code>个分类器中。每一行中<code>n_class - 1</code>个项目对应于这些分类器的对偶系数（dual coefficient）。</p>
<h3 id="得分和概率"><a href="#得分和概率" class="headerlink" title="得分和概率"></a>得分和概率</h3><p><code>SVC</code>中的<code>decision_function</code>方法对每个样本都会给出在各个类别上的分数（在二元分类问题中，是对每个样本给出一个分数）。如果构造函数的<code>probability</code>被设为<code>True</code>，则可以得到属于每个类别的概率估计（通过<code>predict_proba</code>和<code>predict_log_proba</code>方法）。在二元分类中，概率使用Platt缩放进行调整：通过在训练机上做额外的交叉检验来拟合一个在SVM分数上的Logistic回归。在多元分类中，这种方法被Wu et al. (2004)扩展了。</p>
<p>显而易见的是，Platt缩放中的交叉检验在大数据集上是一个代价很高的操作。此外，概率估计与实际得分可能会不一致，即使得分取得了最大值，概率并不一定也能取到最大值。（例如在二元分类中，某个样本经由<code>predict</code>方法得到的分类标签，如果使用<code>predict_proba</code>计算可能概率小于1/2。）Platt的方法在理论上也有一些问题。如果需要拿到置信分数，而这些分数又不一定非得是概率，则建议把<code>probability</code>置为<code>False</code>，并且使用<code>decision_function</code>，而不是<code>predict_proba</code>。</p>
<blockquote>
<p>参考文献：</p>
<ul>
<li>Wu, Lin and Weng, <a href="http://www.csie.ntu.edu.tw/~cjlin/papers/svmprob/svmprob.pdf" target="_blank" rel="external">“Probability estimates for multi-class classification by pairwise coupling”</a>, JMLR 5:975-1005, 2004.</li>
<li><a href="http://www.cs.colorado.edu/~mozer/Teaching/syllabi/6622/papers/Platt1999.pdf" target="_blank" rel="external">Platt “Probabilistic outputs for SVMs and comparisons to regularized likelihood methods” </a>.</li>
</ul>
</blockquote>
<h3 id="不平衡问题"><a href="#不平衡问题" class="headerlink" title="不平衡问题"></a>不平衡问题</h3><p>在某些情况下，一些指定的类别或某几个样本关键字可能更加重要，这时可以使用<code>class_weight</code>和<code>sample_weight</code>。</p>
<p><code>SVC</code>（不是<code>NuSVC</code>）在<code>fit</code>方法中实现了关键字<code>class_weight</code>。该关键字是字典类型，形式为<code>{class_label : value}</code>，这里<code>value</code>是一个正浮点数，将类别<code>class_label</code>的参数<code>C</code>设为<code>C * value</code>。</p>
<p><img src="http://scikit-learn.org/stable/_images/sphx_glr_plot_separating_hyperplane_unbalanced_001.png" alt="sphx_glr_plot_separating_hyperplane_unbalanced_0011"></p>
<p> <code>SVC</code>，<code>NuSVC</code>，<code>SVR</code>，<code>NuSVR</code>和<code>OneClassSVM</code>同样在<code>fit</code>方法中通过关键字<code>sample_weight</code>实现了对单独样本赋予特殊权重的功能。与<code>class_weight</code>类似，它们把第i个样本的参数<code>C</code>设为<code>C * sample_weight[i]</code>。</p>
<p><img src="http://scikit-learn.org/stable/_images/sphx_glr_plot_weighted_samples_001.png" alt="sphx_glr_plot_weighted_samples_0011 (1)"></p>
<blockquote>
<ul>
<li><a href="http://scikit-learn.org/stable/auto_examples/svm/plot_iris.html#example-svm-plot-iris-py" target="_blank" rel="external">在iris数据集中试验不同的SVM分类器，并作图比较</a></li>
<li><a href="http://scikit-learn.org/stable/auto_examples/svm/plot_separating_hyperplane.html#example-svm-plot-separating-hyperplane-py" target="_blank" rel="external">SVM：最大化间隔分离超平面</a></li>
<li><a href="http://scikit-learn.org/stable/auto_examples/svm/plot_separating_hyperplane_unbalanced.html#example-svm-plot-separating-hyperplane-unbalanced-py" target="_blank" rel="external">SVM：不平衡类别的分离超平面</a></li>
<li><a href="http://scikit-learn.org/stable/auto_examples/svm/plot_svm_anova.html#example-svm-plot-svm-anova-py" target="_blank" rel="external">SVM-Anova：带有单变量特征选择的SVM</a></li>
<li><a href="http://scikit-learn.org/stable/auto_examples/svm/plot_svm_nonlinear.html#example-svm-plot-svm-nonlinear-py" target="_blank" rel="external">非线性SVM</a></li>
<li><a href="http://scikit-learn.org/stable/auto_examples/svm/plot_weighted_samples.html#example-svm-plot-weighted-samples-py" target="_blank" rel="external">SVM：带权重问题的例子</a></li>
</ul>
</blockquote>
<h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><p>支持向量分类这样的方法可以经扩展用在回归问题上，称作支持向量回归。</p>
<p>支持向量分类产生的模型，如上所述，只依赖于训练数据的一个子集。其原因在于，构造模型时用到的代价函数并不关心那些不在边界上的数据点。类似的，支持向量回归所生成的模型也只依赖于训练数据的一个自己，因为构造模型时用到的代价函数用不上那些与预测值很接近的训练数据。</p>
<p>支持向量回归有三种不同实现：<a href="http://scikit-learn.org/stable/modules/generated/sklearn.svm.SVR.html#sklearn.svm.SVR" target="_blank" rel="external"><code>SVR</code></a>, <a href="http://scikit-learn.org/stable/modules/generated/sklearn.svm.NuSVR.html#sklearn.svm.NuSVR" target="_blank" rel="external"><code>NuSVR</code></a>和<a href="http://scikit-learn.org/stable/modules/generated/sklearn.svm.LinearSVR.html#sklearn.svm.LinearSVR" target="_blank" rel="external"><code>LinearSVR</code></a>。<code>LinearSVR</code>提供的实现比<code>SVR</code>快，但是只使用线性核。<code>NuSVR</code>则是使用了一个略不同的数学原理。细节见后面“实现细节”部分。</p>
<p>与分类问题类似，<code>fit</code>方法接受向量X和y作为参数，不过这里y应该是浮点型而不是整型：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>X = [[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">2</span>, <span class="number">2</span>]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>y = [<span class="number">0.5</span>, <span class="number">2.5</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>clf = svm.SVR()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>clf.fit(X, y) </div><div class="line">SVR(C=<span class="number">1.0</span>, cache_size=<span class="number">200</span>, coef0=<span class="number">0.0</span>, degree=<span class="number">3</span>, epsilon=<span class="number">0.1</span>, gamma=<span class="string">'auto'</span>,</div><div class="line">    kernel=<span class="string">'rbf'</span>, max_iter=<span class="number">-1</span>, shrinking=<span class="keyword">True</span>, tol=<span class="number">0.001</span>, verbose=<span class="keyword">False</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>clf.predict([[<span class="number">1</span>, <span class="number">1</span>]])</div><div class="line">array([ <span class="number">1.5</span>])</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><a href="http://scikit-learn.org/stable/auto_examples/svm/plot_svm_regression.html#example-svm-plot-svm-regression-py" target="_blank" rel="external">使用线性核和非线性核进行支持向量回归（SVR)</a></li>
</ul>
</blockquote>
<h2 id="密度估计与新奇值检测（novelty-detection）"><a href="#密度估计与新奇值检测（novelty-detection）" class="headerlink" title="密度估计与新奇值检测（novelty detection）"></a>密度估计与新奇值检测（novelty detection）</h2><p>单类别SVM可用于新奇值检测，即给定一组样本，检测出该数据集的软边界，以判断新数据点是否属于该数据集。<a href="http://scikit-learn.org/stable/modules/generated/sklearn.svm.OneClassSVM.html#sklearn.svm.OneClassSVM" target="_blank" rel="external"><code>OneClassSVM</code></a>类实现该方法。在这种情况下，由于这是一种无监督学习，数据没有类别标签，因此<code>fit</code>方法只接受数组X作为输入。见<a href="http://scikit-learn.org/stable/modules/outlier_detection.html#outlier-detection" target="_blank" rel="external">新奇值与异常值检测检测</a>一节了解更多用法。</p>
<p><img src="http://scikit-learn.org/stable/_images/sphx_glr_plot_oneclass_001.png" alt="sphx_glr_plot_oneclass_0011"></p>
<blockquote>
<ul>
<li><a href="http://scikit-learn.org/stable/auto_examples/svm/plot_oneclass.html#example-svm-plot-oneclass-py" target="_blank" rel="external">使用非线性核（RBF）的单类别SVM</a></li>
<li><a href="http://scikit-learn.org/stable/auto_examples/applications/plot_species_distribution_modeling.html#example-applications-plot-species-distribution-modeling-py" target="_blank" rel="external">种类分布建模</a></li>
</ul>
</blockquote>
<h2 id="应用建议"><a href="#应用建议" class="headerlink" title="应用建议"></a>应用建议</h2><ul>
<li><strong>避免数据拷贝</strong>：对<code>SVC</code>、<code>SVR</code>、<code>NuSVC</code>和<code>NuSVR</code>，如果传给特定方法的数据不是以C语言所使用的顺序排列，而且是double精度，那么该数据会在调用底层C实现之前被拷贝一份。通过检查<code>flag</code>属性，可以检查给定的numpy数组是否是以C格式的连续存储方式排列的。对<code>LinearSVC</code>和<code>LogisticRegression</code>，任何以numpy数组形式传入的输入都会被拷贝，然后转化为liblinear内部的稀疏数据表示形式（双精度浮点数，对非零元素存储32位整型的索引）。如果你想训练一个大规模的线性分类器，而又不想拷贝一个稠密的numpy C-存储双精度数组，我们建议使用<code>SGDClassifier</code>。可以对它的目标函数进行配置，使其与<code>LinearSVC</code>模型所使用的基本相同。</li>
<li><strong>核缓存大小</strong>：对<code>SVC</code>、<code>SVR</code>、<code>NuSVC</code>和<code>NuSVR</code>，核缓存的大小对较大问题求解的运行时间有非常强的影响。如果你有足够内存，建议将<code>cache_size</code>设置为一个高于默认值200（MB）的值，比如500（MB）或1000（MB）。</li>
<li><strong>设置C</strong>：默认情况下<code>C</code>设为1，这是一个合理的选择。如果样本中有许多噪音观察点，则应该减小这个值。这意味着对估计结果进行更严格的正则化。</li>
<li>SVM算法会受数据取值范围的影响，所以<strong>强烈建议在使用之前对数据进行缩放</strong>。例如把输入向量X的每个属性缩放到[0,1]或[-1,+1]内，或者进行标准化使数据的均值为0方差为1。注意在测试向量上也要进行<strong>同样的</strong>缩放，这样才能得到有意义的结果。关于数据缩放和标准化的更多细节，参见<a href="http://scikit-learn.org/stable/modules/preprocessing.html#preprocessing" target="_blank" rel="external">处理数据</a>一节</li>
<li><code>NuSVC</code>/<code>OneClassVM</code>/<code>NuSVR</code>中的参数<code>mu</code>估计了训练误差和支持向量的比率</li>
<li>在<code>SVC</code>中，如果要分类的数据是不平衡的（如有很多正数据但是很少负数据），应该加选项<code>class_weight=&#39;balanced&#39;</code>然后/或者尝试不同的惩罚项参数<code>C</code>。</li>
<li><code>LinearSVC</code>的底层实现使用了随机数生成器来在拟合模型时选择特征。因此对同样的输入数据有略微不同的结果不是怪事。如果发生了这样的情况，试一个更小的tol参数</li>
<li>利用<code>LinearSVC(loss=&#39;l2&#39;, penalty=&#39;l1&#39;, dual=False)</code>来引入L1惩罚项会产生一个稀疏解，即特征权重中只有一少部分不为0，会对决策函数产生贡献。增加<code>C</code>会产生一个更复杂的模型（有更多特征被选择）。可以通过<a href="http://scikit-learn.org/stable/modules/generated/sklearn.svm.l1_min_c.html#sklearn.svm.l1_min_c" target="_blank" rel="external"><code>l1_min_c</code></a>来计算产生“空”模型（所有权重都是0）的<code>C</code>值。</li>
</ul>
<h2 id="内核函数"><a href="#内核函数" class="headerlink" title="内核函数"></a>内核函数</h2><p>升维的思想简单说来就是：在原来feature的基础上人为的构造一些新的feature，在更高维度的空间里，原来不线性可分的问题就会变成线性可分的问题，就又可以用svm了。</p>
<blockquote>
<p><a href="http://www.zhihu.com/question/30371867" target="_blank" rel="external">对高维空间里的线性可分</a></p>
</blockquote>
<p>升维的思想确实很漂亮，但是现实往往是很骨感的：如果对不同的数据集，每次都要寻找一个合适的函数，来把低维空间中的点x映射到高维空间中去是一件很困难的事情。<br>但是回想一下svm里的最终表达式，其实具体的表达式并不在最终结果里出现，出现的只有内积。如果有办法直接算出高维空间中的新内积，就不需要费力去构造。</p>
<p>核函数（Kernel method）正是基于这一思想的技巧。我们可以把kernel想象成，然后不去操心f(x)，而是尝试不同的核函数就可以了。</p>
<p><strong>核函数</strong>可以有以下几种选择：</p>
<ul>
<li><p>线性（linear）核：<img src="http://scikit-learn.org/stable/_images/math/cc655b2d07d61893992ca7bfb9256b43314933bf.png" alt="\ langle x，x&#39;\ rangle">。</p>
</li>
<li><p>多项式（polynomial）核：<br>$$<br>\left (\gamma \left \langle x, {x}’  \right \rangle +r  \right )^{d}<br>$$<br>。其中d由选项<code>degree</code>指定，r由<code>coef0</code>指定</p>
</li>
<li><p>径向基Gaussian（RBF）函数：<img src="http://scikit-learn.org/stable/_images/math/d571609cf042d44f541e8c11efbc305354206096.png" alt="\ exp（ -  \ gamma \ | x-x&#39;\ | ^ 2）">。其中<br>$$<br>\gamma<br>$$<br>由选项<code>gamma</code>指定，必须大于0</p>
</li>
<li><p>sigmoid函数(<img src="http://scikit-learn.org/stable/_images/math/e5dadad6828c157553e944e605a295afdcc600cf.png" alt="\ tanh（\ gamma \ langle x，x&#39;\ rangle + r）">)，其中由选项<code>coef0</code>指定</p>
</li>
</ul>
<p>在初始化时通过选项<code>kernel</code>指定用什么核</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>linear_svc = svm.SVC(kernel=<span class="string">'linear'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>linear_svc.kernel</div><div class="line"><span class="string">'linear'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>rbf_svc = svm.SVC(kernel=<span class="string">'rbf'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>rbf_svc.kernel</div><div class="line"><span class="string">'rbf'</span></div></pre></td></tr></table></figure>
<h3 id="自定义核"><a href="#自定义核" class="headerlink" title="自定义核"></a>自定义核</h3><p>Scikit提供两种方法来自定义核函数：给参数<code>kernel</code>传入一个python函数，或者提前计算好Gram矩阵。使用自定义核的分类器和其它分类器有类似的行为，不过以下两点除外：</p>
<ul>
<li><code>support_vectors_</code>域为空，只在<code>support_</code>里面存储支持向量的索引</li>
<li>会为<code>fit()</code>方法的第一个参数存储一个引用（不是拷贝），来为以后引用之做准备。如果在调用<code>fit()</code>之后，在调用<code>predict()</code>之前修改这个数组，则会产生一些不可预知的结果。</li>
</ul>
<h4 id="使用Python函数作为核"><a href="#使用Python函数作为核" class="headerlink" title="使用Python函数作为核"></a>使用Python函数作为核</h4><p>可以在构造函数中向参数<code>kernel</code>传进一个函数，来使用自定义的核。该函数必须接受两个大小分别为<code>(n_samples_1, n_features)</code>, <code>(n_samples_2, n_features)</code>的矩阵作为参数，返回一个大小为<code>(n_samples_1, n_samples_2)</code>的核矩阵。</p>
<p>如下代码定义了一个线性核，并使用该核创建了一个分类器实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">my_kernel</span><span class="params">(X, Y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> np.dot(X, Y.T)</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>clf = svm.SVC(kernel=my_kernel)</div></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://scikit-learn.org/stable/auto_examples/svm/plot_custom_kernel.html#example-svm-plot-custom-kernel-py" target="_blank" rel="external">使用自定义核的SVM</a></p>
</blockquote>
<h2 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h2><p>支持向量机的原理是在高维甚至无限维空间中构建一个超平面或者若干超平面组成的集合，并藉此用于分类、回归或其它任务。从直觉上来讲，好的分隔面是由使得函数间隔最大的超平面得到（即该超平面到任何类别最近训练数据点的距离都取得最大值），因为总体上来讲，间隔越大，分类器的泛化误差越小。</p>
<p><img src="http://scikit-learn.org/stable/_images/sphx_glr_plot_separating_hyperplane_0011.png" alt="sphx_glr_plot_separating_hyperplane_0011"></p>
<h3 id="SVC"><a href="#SVC" class="headerlink" title="SVC"></a>SVC</h3><p>给定可能属于某两种类别的训练向量<img src="http://scikit-learn.org/stable/_images/math/3c2810ae28117c8ad2d9464adc7f57ad2143887c.png" alt="3c2810ae28117c8ad2d9464adc7f57ad2143887c">,<code>i=1, ..., n</code>和向量<img src="http://scikit-learn.org/stable/_images/math/ede528003a9c8d8f47c5e4c3c8ed4dc0056b8c36.png" alt="ede528003a9c8d8f47c5e4c3c8ed4dc0056b8c36">，SVC解决的首要问题是</p>
<p><img src="http://scikit-learn.org/stable/_images/math/afe25ea32dba823e13d2ae45b439d4529cd15364.png" alt="afe25ea32dba823e13d2ae45b439d4529cd15364 (1)"></p>
<p>其对偶形式为</p>
<p><img src="http://scikit-learn.org/stable/_images/math/ca662d71b1a44a2cdf255fbe69c8a72803eded1c.png" alt="ca662d71b1a44a2cdf255fbe69c8a72803eded1c (1)"></p>
<p>其中<code>e</code>是全1向量，<code>C &gt; 0</code>是上界，<code>Q</code>是一个半正定矩阵，<img src="http://scikit-learn.org/stable/_images/math/02d6bcb474ff4e171fdd4de3e6d3e3b772b41c8c.png" alt="02d6bcb474ff4e171fdd4de3e6d3e3b772b41c8c">，其中<img src="http://scikit-learn.org/stable/_images/math/4488f5555693ea818a6bb1cb471fa11fdd11b39f.png" alt="4488f5555693ea818a6bb1cb471fa11fdd11b39f">是核。这里训练向量通过函数被隐式映射到一个高维（甚至无限维）空间<img src="http://scikit-learn.org/stable/_images/math/c2f31c22645274c375eff7920cfdfdc18d60341f.png" alt="c2f31c22645274c375eff7920cfdfdc18d60341f">。</p>
<p>决策函数是 <strong>注意</strong>：虽然从<a href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/" target="_blank" rel="external"><code>libsvm</code></a>和<a href="http://www.csie.ntu.edu.tw/~cjlin/liblinear/" target="_blank" rel="external"><code>liblinear</code></a>导出的SVM模型使用<code>C</code>作为正则化参数，但实际上其它更多预测器使用的是<code>alpha</code>。这两个参数之间的关系是</p>
<p><img src="http://scikit-learn.org/stable/_images/math/c4b8feb333aa69aaa37401ee4db26ae4afdbeb63.png" alt="2"></p>
<p>这些参数可以通过各个成员变量访问：<code>dual_coef_</code>存放乘积，<code>support_vectors</code>存放支持向量，<code>intercept_</code>存放独立项：</p>
<blockquote>
<p>参考文献：</p>
<ul>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.17.7215" target="_blank" rel="external">“Automatic Capacity Tuning of Very Large VC-dimension Classifiers”</a>, I. Guyon, B. Boser, V. Vapnik - Advances in neural information processing 1993.</li>
<li><a href="http://link.springer.com/article/10.1007%2FBF00994018" target="_blank" rel="external">“Support-vector networks”</a>, C. Cortes, V. Vapnik - Machine Learning, 20, 273-297 (1995).</li>
</ul>
</blockquote>
<h3 id="NuSVC"><a href="#NuSVC" class="headerlink" title="NuSVC"></a>NuSVC</h3><p>其提供了一个新的参数，控制支持向量的个数和训练误差。参数<img src="http://scikit-learn.org/stable/_images/math/cb88554a78c6610201fd61574c2591aa23da35ac.png" alt="cb88554a78c6610201fd61574c2591aa23da35ac">是训练误差的上限和支持向量的下限。</p>
<p>可以看到<code>v-SVC</code>是<code>C-SVC</code>的一种重参数化形式，因此两者在数学上是等价的。</p>
<h3 id="SVR"><a href="#SVR" class="headerlink" title="SVR"></a>SVR</h3><p>给定训练向量组<img src="http://scikit-learn.org/stable/_images/math/3c2810ae28117c8ad2d9464adc7f57ad2143887c.png" alt="3c2810ae28117c8ad2d9464adc7f57ad2143887c (1)">,<code>i=1, ..., n</code>和向量<img src="http://scikit-learn.org/stable/_images/math/1269782190e528401491505bf582106d5990f870.png" alt="1269782190e528401491505bf582106d5990f870">，<img src="http://scikit-learn.org/stable/_images/math/3cb373a8030ad846aed7b1ee45bab27b13775928.png" alt="3cb373a8030ad846aed7b1ee45bab27b13775928">-SVR要解决的主要问题如下所示：</p>
<p><img src="http://scikit-learn.org/stable/_images/math/84dfa253bd3c36093102158fbe951a73819f96df.png" alt="84dfa253bd3c36093102158fbe951a73819f96df (1)"></p>
<p> 其对偶为</p>
<p><img src="http://scikit-learn.org/stable/_images/math/adfba00b3343f39be094f322b9349d472f29fd63.png" alt="adfba00b3343f39be094f322b9349d472f29fd63 (1)"></p>
<p>其中<code>e</code>是全1向量，<code>C &gt; 0</code>是上界，<code>Q</code>是一个半正定矩阵，<img src="http://scikit-learn.org/stable/_images/math/a3e3a226d8b165a8871e4aa2b981e440ca1ccc1d.png" alt="a3e3a226d8b165a8871e4aa2b981e440ca1ccc1d">是内核。这里训练向量通过函数被隐式映射到一个高维（甚至无限维）空间<img src="http://scikit-learn.org/stable/_images/math/c2f31c22645274c375eff7920cfdfdc18d60341f.png" alt="\披">。</p>
<p>决策函数为</p>
<p><img src="http://scikit-learn.org/stable/_images/math/7b2ae68afb44fc8ac21ce0e4c5028ec7497cb5cc.png" alt="7b2ae68afb44fc8ac21ce0e4c5028ec7497cb5cc (1)"></p>
<p>这些参数可以通过各个成员变量访问。其保持的差<img src="http://scikit-learn.org/stable/_images/math/c7e6ffac97e60b9e6f0c0e0e6efe7425064c0013.png" alt="\ alpha_i  -  \ alpha_i ^ *">，其中变量<code>dual_coef_</code>存储，<code>support_vectors_</code>存储支持向量，<code>intercept_</code>存储独立项<img src="http://scikit-learn.org/stable/_images/math/9a51ab9a0b521705e1e8762fac6bdd6f11771758.png" alt="1">。</p>
<blockquote>
<p>参考文献：</p>
<ul>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.114.4288" target="_blank" rel="external">“A Tutorial on Support Vector Regression”</a>, Alex J. Smola, Bernhard Schölkopf - Statistics and Computing archive Volume 14 Issue 3, August 2004, p. 199-222.</li>
</ul>
</blockquote>
<h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p>在底层，使用 <a href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/" target="_blank" rel="external">libsvm</a> 和 <a href="http://www.csie.ntu.edu.tw/~cjlin/liblinear/" target="_blank" rel="external">liblinear</a> 来处理所有计算逻辑。这些库是被C和Cython包装的。</p>
<blockquote>
<p><strong>参考文献</strong>：</p>
<ul>
<li><a href="http://www.csie.ntu.edu.tw/~cjlin/papers/libsvm.pdf" target="_blank" rel="external">LIBSVM: a library for Support Vector Machines</a></li>
<li><a href="http://www.csie.ntu.edu.tw/~cjlin/liblinear/" target="_blank" rel="external">LIBLINEAR – A Library for Large Linear Classification</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;script type=&quot;text/javascript&quot; async src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML&quot;&gt;&lt;/script&gt;

&lt;p&gt;文章排版还有问题，待修改&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;支持向量机（SVM）是用于分类，回归和异常值检测的监督学习方法。&lt;/p&gt;
&lt;p&gt;支持向量机的优点包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在高维空间中行之有效。&lt;/li&gt;
&lt;li&gt;当维数大于样本数时仍然可用。&lt;/li&gt;
&lt;li&gt;在决策函数中只使用训练点的一个子集（称为支持向量），大大节省了内存开销。&lt;/li&gt;
&lt;li&gt;用途广泛：决策函数中可以使用不同的&lt;a href=&quot;http://scikit-learn.org/stable/modules/svm.html#svm-kernels&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;核函数&lt;/a&gt;。提供了一种通用的核，但是也可以指定自定义的核。&lt;/li&gt;
&lt;li&gt;返回的分割直线满足margin最大的条件，所以是一个robust的解。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SVM对数据点的依赖是稀疏的&lt;/strong&gt;，只有少量支持向量对最终结果有贡献。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而其劣势在于&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果特征数量远大于样本数量，则表现会比较差。&lt;/li&gt;
&lt;li&gt;SVM不直接提供概率估计。这个值通过五折交叉验证计算，代价比较高（见下面“跑分与概率”一节）。&lt;/li&gt;
&lt;li&gt;首先SVM的优化问题比较复杂，不仅人难以理解，写起程序来也比较复杂，必须要用到Sequential minimal optimization（SMO）。&lt;/li&gt;
&lt;li&gt;其次，传统的SVM只能处理线性可分的问题，并且对数据中的噪音也很敏感，因此我们必要对算法进行改造。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Scikit-learn中的支持向量机同时支持密集样本向量（&lt;code&gt;numpy.ndarray&lt;/code&gt;和可通过&lt;code&gt;numpy.asarray&lt;/code&gt;转化的数据类型）和稀疏样本向量（任何&lt;code&gt;scipy.sparse&lt;/code&gt;对象）。但是如果想用SVM对稀疏数据进行预测，则必须先在这些数据上拟合。为了优化性能，应该使用C阶（C-Ordered）&lt;code&gt;numpy.ndarray&lt;/code&gt;（密集的）或&lt;code&gt;scipy.sparse.csr_matrix&lt;/code&gt;（稀疏的），并指定&lt;code&gt;dtype=float64&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
      <category term="SVM" scheme="http://yoursite.com/tags/SVM/"/>
    
  </entry>
  
  <entry>
    <title>数据表查询</title>
    <link href="http://yoursite.com/2017/09/19/Query%20database/"/>
    <id>http://yoursite.com/2017/09/19/Query database/</id>
    <published>2017-09-19T05:53:24.000Z</published>
    <updated>2017-10-30T03:16:04.028Z</updated>
    
    <content type="html"><![CDATA[<p>数据查询是数据库操作的核心操作。SQL提供了<code>SELECT</code>语句进行数据查询，其一般格式为：</p>
<p><code>SELECT [ALL | DISTINCT] &lt;目标列表达式&gt; FROM &lt;表名或视图名&gt; (&lt;SELECT 语句&gt;) [AS] &lt;别名&gt; [WHERE&lt;条件表达式&gt;]</code></p>
<a id="more"></a>
<p>以下操作，都以下表为模型。</p>
<h5 id="Student"><a href="#Student" class="headerlink" title="Student"></a>Student</h5><table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Sname</th>
<th style="text-align:center">Ssex</th>
<th style="text-align:center">Sage</th>
<th style="text-align:center">Sdept</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">201215121</td>
<td style="text-align:center">Yong Li</td>
<td style="text-align:center">M</td>
<td style="text-align:center">20</td>
<td style="text-align:center">CS</td>
</tr>
<tr>
<td style="text-align:center">201215122</td>
<td style="text-align:center">Chen Liu</td>
<td style="text-align:center">F</td>
<td style="text-align:center">19</td>
<td style="text-align:center">CS</td>
</tr>
<tr>
<td style="text-align:center">201215123</td>
<td style="text-align:center">Min Wang</td>
<td style="text-align:center">F</td>
<td style="text-align:center">18</td>
<td style="text-align:center">MA</td>
</tr>
<tr>
<td style="text-align:center">201215125</td>
<td style="text-align:center">Li Zhang</td>
<td style="text-align:center">M</td>
<td style="text-align:center">19</td>
<td style="text-align:center">IS</td>
</tr>
</tbody>
</table>
<h5 id="Course"><a href="#Course" class="headerlink" title="Course"></a>Course</h5><table>
<thead>
<tr>
<th style="text-align:center">Cno</th>
<th style="text-align:center">Cname</th>
<th style="text-align:center">Cpno</th>
<th style="text-align:center">Ccredit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">Data base</td>
<td style="text-align:center">5</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">Mathematics</td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">Information system</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">Operating system</td>
<td style="text-align:center">6</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">Data structure</td>
<td style="text-align:center">7</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">Data processing</td>
<td style="text-align:center"></td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">PASCAL language</td>
<td style="text-align:center">6</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
<h5 id="SC"><a href="#SC" class="headerlink" title="SC"></a>SC</h5><table>
<thead>
<tr>
<th style="text-align:center">Sno</th>
<th style="text-align:center">Cno</th>
<th style="text-align:center">Grade</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">201215121</td>
<td style="text-align:center">1</td>
<td style="text-align:center">92</td>
</tr>
<tr>
<td style="text-align:center">201215121</td>
<td style="text-align:center">2</td>
<td style="text-align:center">85</td>
</tr>
<tr>
<td style="text-align:center">201215121</td>
<td style="text-align:center">3</td>
<td style="text-align:center">88</td>
</tr>
<tr>
<td style="text-align:center">201215122</td>
<td style="text-align:center">2</td>
<td style="text-align:center">90</td>
</tr>
<tr>
<td style="text-align:center">201215122</td>
<td style="text-align:center">3</td>
<td style="text-align:center">80</td>
</tr>
</tbody>
</table>
<h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><h3 id="选择表中的若干列"><a href="#选择表中的若干列" class="headerlink" title="选择表中的若干列"></a>选择表中的若干列</h3><p>选择表中的全部或若干列即关系代数的投影运算。</p>
<h4 id="查询指定列"><a href="#查询指定列" class="headerlink" title="查询指定列"></a>查询指定列</h4><h5 id="查询全体学生的学号和姓名"><a href="#查询全体学生的学号和姓名" class="headerlink" title="查询全体学生的学号和姓名"></a>查询全体学生的学号和姓名</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> SNO, SNAME </div><div class="line"><span class="keyword">from</span> Student;</div></pre></td></tr></table></figure>
<blockquote>
<p>目标表达式中的各列先后顺序可以不同</p>
</blockquote>
<h4 id="查询全部列"><a href="#查询全部列" class="headerlink" title="查询全部列"></a>查询全部列</h4><h5 id="查询全体学生的详细记录"><a href="#查询全体学生的详细记录" class="headerlink" title="查询全体学生的详细记录"></a>查询全体学生的详细记录</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * </div><div class="line"><span class="keyword">from</span> Student;</div></pre></td></tr></table></figure>
<h4 id="查询经过计算的值"><a href="#查询经过计算的值" class="headerlink" title="查询经过计算的值"></a>查询经过计算的值</h4><h5 id="查询全体学生的姓名及出生年份"><a href="#查询全体学生的姓名及出生年份" class="headerlink" title="查询全体学生的姓名及出生年份"></a>查询全体学生的姓名及出生年份</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> SNAME, <span class="number">2017</span>-SAGE </div><div class="line"><span class="keyword">from</span> Student;</div></pre></td></tr></table></figure>
<blockquote>
<p>查询结果中第 2 列不是列名，而是一个计算表达式，用当前年份减去学生年龄，所得到的即是学生的出生年份。</p>
</blockquote>
<h5 id="查询所有学生姓名、出生年份和所在院系，要求用小写字母表示系名"><a href="#查询所有学生姓名、出生年份和所在院系，要求用小写字母表示系名" class="headerlink" title="查询所有学生姓名、出生年份和所在院系，要求用小写字母表示系名"></a>查询所有学生姓名、出生年份和所在院系，要求用小写字母表示系名</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> SNAME, <span class="number">2017</span>-SAGE, <span class="keyword">lower</span>(SDEPT) </div><div class="line"><span class="keyword">from</span> Student;</div></pre></td></tr></table></figure>
<h5 id="查询所有学生姓名、出生年份和所在院系，要求用小写字母表示系名，并分别使用别名标识"><a href="#查询所有学生姓名、出生年份和所在院系，要求用小写字母表示系名，并分别使用别名标识" class="headerlink" title="查询所有学生姓名、出生年份和所在院系，要求用小写字母表示系名，并分别使用别名标识"></a>查询所有学生姓名、出生年份和所在院系，要求用小写字母表示系名，并分别使用别名标识</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> SNAME <span class="keyword">as</span> <span class="keyword">NAME</span>, <span class="number">2017</span>-SAGE <span class="keyword">as</span> BIRTHDAY, <span class="keyword">lower</span>(SDEPT) <span class="keyword">as</span> DEPARTMENT </div><div class="line"><span class="keyword">from</span> Student;</div></pre></td></tr></table></figure>
<blockquote>
<p>其中<code>as</code>可以省略</p>
</blockquote>
<h3 id="选择表中若干元组"><a href="#选择表中若干元组" class="headerlink" title="选择表中若干元组"></a>选择表中若干元组</h3><h4 id="消除取值重复的行"><a href="#消除取值重复的行" class="headerlink" title="消除取值重复的行"></a>消除取值重复的行</h4><h5 id="查询选修了课程的学生学号"><a href="#查询选修了课程的学生学号" class="headerlink" title="查询选修了课程的学生学号"></a>查询选修了课程的学生学号</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> SNO </div><div class="line"><span class="keyword">from</span> SC;</div></pre></td></tr></table></figure>
<blockquote>
<p>如果没有<code>distinct</code>关键词，则默认为<code>all</code>。</p>
</blockquote>
<h4 id="查询满足条件的元组"><a href="#查询满足条件的元组" class="headerlink" title="查询满足条件的元组"></a>查询满足条件的元组</h4><h5 id="比较大小"><a href="#比较大小" class="headerlink" title="比较大小"></a>比较大小</h5><h6 id="查询所有年龄小于20岁的学生姓名及年龄"><a href="#查询所有年龄小于20岁的学生姓名及年龄" class="headerlink" title="查询所有年龄小于20岁的学生姓名及年龄"></a>查询所有年龄小于20岁的学生姓名及年龄</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> SNAME, SAGE </div><div class="line"><span class="keyword">from</span> Student </div><div class="line"><span class="keyword">where</span> SAGE&lt;<span class="number">20</span>;</div></pre></td></tr></table></figure>
<h5 id="确定范围"><a href="#确定范围" class="headerlink" title="确定范围"></a>确定范围</h5><h6 id="查询年龄在20-23岁之间的学生姓名，系别和年龄。"><a href="#查询年龄在20-23岁之间的学生姓名，系别和年龄。" class="headerlink" title="查询年龄在20~23岁之间的学生姓名，系别和年龄。"></a>查询年龄在20~23岁之间的学生姓名，系别和年龄。</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> SNAME, SDEPT, SAGE </div><div class="line"><span class="keyword">from</span> Student </div><div class="line"><span class="keyword">where</span> SAGE <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">23</span>;</div></pre></td></tr></table></figure>
<h6 id="查询年龄不在20-23岁之间的学生姓名，系别和年龄。"><a href="#查询年龄不在20-23岁之间的学生姓名，系别和年龄。" class="headerlink" title="查询年龄不在20~23岁之间的学生姓名，系别和年龄。"></a>查询年龄不在20~23岁之间的学生姓名，系别和年龄。</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> SNAME, SDEPT, SAGE </div><div class="line"><span class="keyword">from</span> Student </div><div class="line"><span class="keyword">where</span> SAGE <span class="keyword">not</span> <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">23</span>;</div></pre></td></tr></table></figure>
<h5 id="确定集合"><a href="#确定集合" class="headerlink" title="确定集合"></a>确定集合</h5><h6 id="查询CS，MA，IS学生的姓名和性别"><a href="#查询CS，MA，IS学生的姓名和性别" class="headerlink" title="查询CS，MA，IS学生的姓名和性别"></a>查询CS，MA，IS学生的姓名和性别</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> SNAME, SSEX </div><div class="line"><span class="keyword">from</span> Student </div><div class="line"><span class="keyword">where</span> SDEPT <span class="keyword">in</span> (<span class="string">'CS'</span>, <span class="string">'MA'</span>, <span class="string">'IS'</span>);</div></pre></td></tr></table></figure>
<h6 id="查询不在CS，MA，IS学生的姓名和性别"><a href="#查询不在CS，MA，IS学生的姓名和性别" class="headerlink" title="查询不在CS，MA，IS学生的姓名和性别"></a>查询不在CS，MA，IS学生的姓名和性别</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> SNAME, SSEX </div><div class="line"><span class="keyword">from</span> Student </div><div class="line"><span class="keyword">where</span> SDEPT <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">'CS'</span>, <span class="string">'MA'</span>, <span class="string">'IS'</span>);</div></pre></td></tr></table></figure>
<h5 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h5><p>谓词<code>LIKE</code>可以用来进行字符串的匹配。其一般语法格式为：</p>
<p><code>[NOT] LIKE &#39;&lt;匹配串&gt;&#39; [ESCAPE &#39;&lt;转码字符&gt;&#39;]</code></p>
<ul>
<li><code>%</code>代表任意长度（长度可以是0）的字符串。</li>
<li><code>_</code>代表任意单个字符。</li>
</ul>
<blockquote>
<p>在查询匹配字符串中如果本身含有<code>%</code>或<code>_</code>，这时需要使用<code>ESCAPE &#39;&lt;转码字符&gt;&#39;</code>短语对通配符进行转义。</p>
</blockquote>
<h6 id="查询学号为’201215121’的学生的详细情况"><a href="#查询学号为’201215121’的学生的详细情况" class="headerlink" title="查询学号为’201215121’的学生的详细情况"></a>查询学号为’201215121’的学生的详细情况</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> * </div><div class="line"><span class="keyword">from</span> Student </div><div class="line"><span class="keyword">where</span> SNO <span class="keyword">like</span> <span class="string">'201215121'</span>;</div></pre></td></tr></table></figure>
<h6 id="查询所有姓’Liu’的学生姓名，学号和性别"><a href="#查询所有姓’Liu’的学生姓名，学号和性别" class="headerlink" title="查询所有姓’Liu’的学生姓名，学号和性别"></a>查询所有姓’Liu’的学生姓名，学号和性别</h6><figure class="highlight sql"><figcaption><span>lite</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> SNAME, SNO, SSEX </div><div class="line"><span class="keyword">from</span> Student</div><div class="line"><span class="keyword">where</span> SNAME <span class="keyword">like</span> <span class="string">'Liu%'</span>;</div></pre></td></tr></table></figure>
<h6 id="查询DB-Design课程的课程号和学分"><a href="#查询DB-Design课程的课程号和学分" class="headerlink" title="查询DB_Design课程的课程号和学分"></a>查询DB_Design课程的课程号和学分</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> CNO, CCREDIT </div><div class="line"><span class="keyword">from</span> Course </div><div class="line"><span class="keyword">where</span> CNAME <span class="keyword">like</span> <span class="string">'DB\_Design'</span> escape <span class="string">'\';</span></div></pre></td></tr></table></figure>
<h5 id="涉及空值的查询"><a href="#涉及空值的查询" class="headerlink" title="涉及空值的查询"></a>涉及空值的查询</h5><h6 id="查询所有有成绩的学生的学号和成绩"><a href="#查询所有有成绩的学生的学号和成绩" class="headerlink" title="查询所有有成绩的学生的学号和成绩"></a>查询所有有成绩的学生的学号和成绩</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> SNO, GRADE </div><div class="line"><span class="keyword">from</span> SC </div><div class="line"><span class="keyword">where</span> GRADE <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</div></pre></td></tr></table></figure>
<h5 id="多重条件查询"><a href="#多重条件查询" class="headerlink" title="多重条件查询"></a>多重条件查询</h5><h6 id="查新CS系年龄在20岁以下的学生姓名"><a href="#查新CS系年龄在20岁以下的学生姓名" class="headerlink" title="查新CS系年龄在20岁以下的学生姓名"></a>查新CS系年龄在20岁以下的学生姓名</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> SNAME </div><div class="line"><span class="keyword">from</span> SC</div><div class="line"><span class="keyword">where</span> SAGE&lt;<span class="number">20</span> <span class="keyword">and</span> SDEPT=<span class="string">'CS'</span>;</div></pre></td></tr></table></figure>
<h3 id="ORDER-BY-子句"><a href="#ORDER-BY-子句" class="headerlink" title="ORDER BY 子句"></a>ORDER BY 子句</h3><p>可以用<code>ORDER BY</code>子句对查询结果进行升序（<code>ASC</code>）或降序（<code>DESC</code>）排列。默认为升序。</p>
<h6 id="查询选修了3号课程的学生的学号和成绩，查询结果按分数降序排列。"><a href="#查询选修了3号课程的学生的学号和成绩，查询结果按分数降序排列。" class="headerlink" title="查询选修了3号课程的学生的学号和成绩，查询结果按分数降序排列。"></a>查询选修了3号课程的学生的学号和成绩，查询结果按分数降序排列。</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> SNO, Grade </div><div class="line"><span class="keyword">from</span> SC</div><div class="line"><span class="keyword">where</span> Cno=<span class="string">'3'</span></div><div class="line"><span class="keyword">order</span> <span class="keyword">by</span> GRADE <span class="keyword">desc</span>;</div></pre></td></tr></table></figure>
<h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><p>为进一步方便用户，增强检索功能，SQL提供了如下聚集函数：</p>
<table>
<thead>
<tr>
<th style="text-align:center">函数名</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">COUNT(*)</td>
<td style="text-align:center">统计元组个数</td>
</tr>
<tr>
<td style="text-align:center">COUNT([DISTINCT\ALL] &lt;列名&gt;)</td>
<td style="text-align:center">统计一列中值得个数</td>
</tr>
<tr>
<td style="text-align:center">SUM([DISTINCT\ALL] &lt;列名&gt;)</td>
<td style="text-align:center">计算一列值得总和（此列必须是数值类型）</td>
</tr>
<tr>
<td style="text-align:center">AVG([DISTINCT\ALL] &lt;列名&gt;)</td>
<td style="text-align:center">计算一列值得平均值（此列必须是数值类型）</td>
</tr>
<tr>
<td style="text-align:center">MAX([DISTINCT\ALL] &lt;列名&gt;)</td>
<td style="text-align:center">求一列值中的最大值</td>
</tr>
<tr>
<td style="text-align:center">MIN([DISTINCT\ALL] &lt;列名&gt;)</td>
<td style="text-align:center">求一列值中的最小值</td>
</tr>
</tbody>
</table>
<h6 id="查询学生总人数"><a href="#查询学生总人数" class="headerlink" title="查询学生总人数"></a>查询学生总人数</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*)</div><div class="line"><span class="keyword">from</span> Student;</div></pre></td></tr></table></figure>
<h6 id="查询选修了课程的学生人数"><a href="#查询选修了课程的学生人数" class="headerlink" title="查询选修了课程的学生人数"></a>查询选修了课程的学生人数</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> SNO)</div><div class="line"><span class="keyword">from</span> SC;</div></pre></td></tr></table></figure>
<h6 id="计算选修1号课程的学生平均成绩"><a href="#计算选修1号课程的学生平均成绩" class="headerlink" title="计算选修1号课程的学生平均成绩"></a>计算选修1号课程的学生平均成绩</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">avg</span>(Grade)</div><div class="line"><span class="keyword">from</span> SC</div><div class="line"><span class="keyword">where</span> SNO=<span class="string">'1'</span>;</div></pre></td></tr></table></figure>
<h6 id="查新选修1号课程的学生最高分数"><a href="#查新选修1号课程的学生最高分数" class="headerlink" title="查新选修1号课程的学生最高分数"></a>查新选修1号课程的学生最高分数</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">max</span>(Grade)</div><div class="line"><span class="keyword">from</span> SC</div><div class="line"><span class="keyword">where</span> CNO=<span class="string">'1'</span>;</div></pre></td></tr></table></figure>
<h3 id="GROUP-BY子句"><a href="#GROUP-BY子句" class="headerlink" title="GROUP BY子句"></a>GROUP BY子句</h3><p><code>GROUP BY</code>子句将查询结果按某一列或多列的值分组，值相等为一组。</p>
<p><strong>分组后聚集函数将作用与每一个组，即每一组都有一个函数值。</strong></p>
<h6 id="求各个课程号及相应的选课人数"><a href="#求各个课程号及相应的选课人数" class="headerlink" title="求各个课程号及相应的选课人数"></a>求各个课程号及相应的选课人数</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> CNO, <span class="keyword">count</span>(SNO)</div><div class="line"><span class="keyword">from</span> SC</div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> CNO;</div></pre></td></tr></table></figure>
<h6 id="查询平均成绩大于等于90分的学生学号和平均成绩"><a href="#查询平均成绩大于等于90分的学生学号和平均成绩" class="headerlink" title="查询平均成绩大于等于90分的学生学号和平均成绩"></a>查询平均成绩大于等于90分的学生学号和平均成绩</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> SNO, <span class="keyword">avg</span>(Grade)</div><div class="line"><span class="keyword">from</span> SC</div><div class="line"><span class="keyword">group</span> <span class="keyword">by</span> SNO</div><div class="line"><span class="keyword">having</span> <span class="keyword">avg</span>(Grade)&gt;=<span class="number">90</span></div></pre></td></tr></table></figure>
<blockquote>
<p><code>WHERE</code>子句中是不能用聚集函数作为条件表达式，应用<code>HAVING</code></p>
</blockquote>
<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><h3 id="等值于非等值连接查询"><a href="#等值于非等值连接查询" class="headerlink" title="等值于非等值连接查询"></a>等值于非等值连接查询</h3><p>连接查询的WHERE子句中用来连接两个表的条件称为连接条件或连接谓词，格式为：</p>
<p><code>[&lt;表名1&gt;.] &lt;列名1&gt;&lt;比较运算符&gt; [&lt;表名2&gt;.] &lt;列名2&gt;</code></p>
<p><code>[&lt;表名1&gt;.] &lt;列名1&gt;BETWEEN [&lt;表名2&gt;.] &lt;列名2&gt;AND [&lt;表名3&gt;.] &lt;列名3&gt;</code></p>
<h6 id="查询每个学生及其选修课程情况"><a href="#查询每个学生及其选修课程情况" class="headerlink" title="查询每个学生及其选修课程情况"></a>查询每个学生及其选修课程情况</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> Student.*, SC.*</div><div class="line"><span class="keyword">from</span> Student, SC</div><div class="line"><span class="keyword">where</span> Student.SNO=SC.SNO;</div></pre></td></tr></table></figure>
<h6 id="查询选修2号课程且成绩在90分以上的所有学生的学号和姓名"><a href="#查询选修2号课程且成绩在90分以上的所有学生的学号和姓名" class="headerlink" title="查询选修2号课程且成绩在90分以上的所有学生的学号和姓名"></a>查询选修2号课程且成绩在90分以上的所有学生的学号和姓名</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> Student.SNO, Sname</div><div class="line"><span class="keyword">from</span> Student, SC</div><div class="line"><span class="keyword">where</span> Student.SNO=SC.SNO <span class="keyword">and</span> SC.CNO=<span class="string">'2'</span> <span class="keyword">and</span> SC.Grade&gt;<span class="number">90</span>;</div></pre></td></tr></table></figure>
<h3 id="自身连接"><a href="#自身连接" class="headerlink" title="自身连接"></a>自身连接</h3><h6 id="查询每一门课的间接先修课"><a href="#查询每一门课的间接先修课" class="headerlink" title="查询每一门课的间接先修课"></a>查询每一门课的间接先修课</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> FIRST.CNO, SECOND.CPNO</div><div class="line"><span class="keyword">from</span> Course <span class="keyword">FIRST</span>, Course <span class="keyword">SECOND</span></div><div class="line"><span class="keyword">where</span> FIRST.SPNO=SECOND.CNO;</div></pre></td></tr></table></figure>
<h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><h6 id="查询每个学生及其选修课程情况-1"><a href="#查询每个学生及其选修课程情况-1" class="headerlink" title="查询每个学生及其选修课程情况"></a>查询每个学生及其选修课程情况</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> Student.SNO, SNAME, SSEX, SAGE, SDEPT, CNO, GRADE</div><div class="line"><span class="keyword">from</span> Student <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> SC <span class="keyword">on</span> (Student.SNO=SC.SNO);</div></pre></td></tr></table></figure>
<h3 id="多表连接"><a href="#多表连接" class="headerlink" title="多表连接"></a>多表连接</h3><h6 id="查询每个学生的学号，姓名，选修的课程名称及成绩"><a href="#查询每个学生的学号，姓名，选修的课程名称及成绩" class="headerlink" title="查询每个学生的学号，姓名，选修的课程名称及成绩"></a>查询每个学生的学号，姓名，选修的课程名称及成绩</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> Student.SNO, SNAME, CNAME, GRADE</div><div class="line"><span class="keyword">from</span> Student, SC, Course</div><div class="line"><span class="keyword">where</span> Student.SNO=SC.SNO <span class="keyword">and</span> SC.CNO=Course.CNO;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数据查询是数据库操作的核心操作。SQL提供了&lt;code&gt;SELECT&lt;/code&gt;语句进行数据查询，其一般格式为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SELECT [ALL | DISTINCT] &amp;lt;目标列表达式&amp;gt; FROM &amp;lt;表名或视图名&amp;gt; (&amp;lt;SELECT 语句&amp;gt;) [AS] &amp;lt;别名&amp;gt; [WHERE&amp;lt;条件表达式&amp;gt;]&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="DataBase" scheme="http://yoursite.com/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>VPS搭载ss实现科学上网</title>
    <link href="http://yoursite.com/2017/09/18/The%20Usage%20of%20traffic-proxy%20in%20Shadowsocks%20at%20VPS/"/>
    <id>http://yoursite.com/2017/09/18/The Usage of traffic-proxy in Shadowsocks at VPS/</id>
    <published>2017-09-18T13:01:35.000Z</published>
    <updated>2017-09-18T13:17:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>简而言之，想使用shadowsocks翻墙，需要一个客户端和一个服务端。</p>
<p>这篇文章主要是如何在VPS上配置shadowsocks，并使用代理实现科学上网。</p>
<a id="more"></a>
<h2 id="登录VPS服务器"><a href="#登录VPS服务器" class="headerlink" title="登录VPS服务器"></a>登录VPS服务器</h2><p>在终端中输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -i [PATH_TO_PRIVATE_KEY] [USERNAME]@[EXTERNAL_IP_ADDRESS]</div></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>[PATH_TO_PRIVATE_KEY]</code>是私钥路径。</li>
<li><code>[USERNAME]</code>是连接到VPS的用户的名称。</li>
<li><code>[EXTERNAL_IP_ADDRESS]</code> 是VPS的外部IP地址。</li>
</ul>
</blockquote>
<h2 id="下载shadowsocks客户端"><a href="#下载shadowsocks客户端" class="headerlink" title="下载shadowsocks客户端"></a>下载shadowsocks客户端</h2><h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum install python-setuptools &amp;&amp; easy_install pip</div><div class="line">pip install shadowsocks</div></pre></td></tr></table></figure>
<h3 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian/Ubuntu:"></a>Debian/Ubuntu:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-get install python-pip</div><div class="line">pip install shadowsocks</div></pre></td></tr></table></figure>
<p>有时Ubuntu会遇到第一个命令安装python-pip时找不到包的情况。pip官方给出了一个安装脚本，可以自动安装pip。先下载脚本，然后执行即可：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget https://bootstrap.pypa.io/get-pip.py</div><div class="line">python get-pip.py</div></pre></td></tr></table></figure>
<p>或者使用easy_install安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo easy_install shadowsocks</div></pre></td></tr></table></figure>
<h2 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h2><p>shadowsocks启动时的参数，如服务器端口，代理端口，登录密码等，可以通过启动时的命令行参数来设定，也可以通过json格式的配置文件设定。推荐使用配置文件，方便查看和修改。</p>
<p>用vi新建一个配置文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /etc/shadowsocks.json</div></pre></td></tr></table></figure>
<p>然后输入如下内容：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&#123; </div><div class="line">   <span class="attr">"server"</span>: <span class="string">"0.0.0.0"</span>,</div><div class="line">    <span class="attr">"server_ipv6"</span>: <span class="string">"::"</span>,</div><div class="line">    <span class="attr">"server_port"</span>: <span class="number">443</span>,</div><div class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</div><div class="line">    <span class="attr">"local_port"</span>: <span class="number">1081</span>,</div><div class="line">    <span class="attr">"port_password"</span>:&#123;</div><div class="line">        <span class="attr">"port_1"</span>:<span class="string">"password_1"</span>,</div><div class="line">        <span class="attr">"port_2"</span>:<span class="string">"pawwword_2"</span></div><div class="line">        &#125;,</div><div class="line">    <span class="attr">"timeout"</span>: <span class="number">120</span>,</div><div class="line">    <span class="attr">"udp_timeout"</span>: <span class="number">60</span>,</div><div class="line">    <span class="attr">"method"</span>: <span class="string">"chacha20"</span>,</div><div class="line">    <span class="attr">"protocol"</span>: <span class="string">"auth_sha1_v4_compatible"</span>,</div><div class="line">    <span class="attr">"protocol_param"</span>: <span class="string">""</span>,</div><div class="line">    <span class="attr">"obfs"</span>: <span class="string">"tls1.2_ticket_auth_compatible"</span>,</div><div class="line">    <span class="attr">"obfs_param"</span>: <span class="string">""</span>,</div><div class="line">    <span class="attr">"dns_ipv6"</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">"connect_verbose_info"</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">"redirect"</span>: <span class="string">""</span>,</div><div class="line">    <span class="attr">"fast_open"</span>: <span class="literal">false</span>,</div><div class="line">    <span class="attr">"workers"</span>: <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单说明一下各个配置项：</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>你的VPS服务器的IP地址</p>
<h3 id="server-port"><a href="#server-port" class="headerlink" title="server_port"></a>server_port</h3><p>你的shadowsocks服务端口。一般可以填一个1025到49151之间的数字。不过需要注意的是，这里的是外部端口，使用时应避免和其它端口重复</p>
<h3 id="local-address"><a href="#local-address" class="headerlink" title="local_address"></a>local_address</h3><p>本地IP地址，作为服务器使用的时候可以不用关注，填127.0.0.1即可。</p>
<h3 id="local-port"><a href="#local-port" class="headerlink" title="local_port"></a>local_port</h3><p>本地端口，也不用关注。</p>
<h3 id="port-password"><a href="#port-password" class="headerlink" title="port_password"></a>port_password</h3><p>你的shadowsocks端口和服务密码，客户端连接时需要填写的。如果需要多人共享，则每个之间用 <code>,</code> 隔开。端口使用时应注意是否被防火墙隔离。</p>
<h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h3><p>超时时间，如果当心网络不好可以设置大一点。</p>
<h3 id="method"><a href="#method" class="headerlink" title="method"></a>method</h3><p>加密方式。</p>
<h3 id="fast-open"><a href="#fast-open" class="headerlink" title="fast_open"></a>fast_open</h3><p>在Ubuntu上建议填True。</p>
<p>填好以后保存退出。</p>
<h3 id="启动shadowsocks"><a href="#启动shadowsocks" class="headerlink" title="启动shadowsocks"></a>启动shadowsocks</h3><p>如果已经写好了配置文件，启动shadowsocks服务器的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssserver -c /etc/shadowsocks.json</div></pre></td></tr></table></figure>
<p>后台启动和停止shadowsocks服务器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssserver -c /etc/shadowsocks.json -d start</div><div class="line">ssserver -c /etc/shadowsocks.json -d stop</div></pre></td></tr></table></figure>
<p>shadowsocks的日志保存在</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/var/log/shadowsocks.log</div></pre></td></tr></table></figure>
<h2 id="安装锐速"><a href="#安装锐速" class="headerlink" title="安装锐速"></a>安装锐速</h2><h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget -N --no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh &amp;&amp; bash serverspeeder-all.sh</div></pre></td></tr></table></figure>
<h3 id="卸载："><a href="#卸载：" class="headerlink" title="卸载："></a>卸载：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f</div></pre></td></tr></table></figure>
<h3 id="开启："><a href="#开启：" class="headerlink" title="开启："></a>开启：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service serverSpeeder start</div></pre></td></tr></table></figure>
<h3 id="查看状态："><a href="#查看状态：" class="headerlink" title="查看状态："></a>查看状态：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">service serverSpeeder status</div></pre></td></tr></table></figure>
<blockquote>
<p>需要在<code>root</code>模式下进行</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简而言之，想使用shadowsocks翻墙，需要一个客户端和一个服务端。&lt;/p&gt;
&lt;p&gt;这篇文章主要是如何在VPS上配置shadowsocks，并使用代理实现科学上网。&lt;/p&gt;
    
    </summary>
    
      <category term="Tutorial" scheme="http://yoursite.com/categories/Tutorial/"/>
    
    
      <category term="ShadowSocks" scheme="http://yoursite.com/tags/ShadowSocks/"/>
    
  </entry>
  
  <entry>
    <title>MySQL修改root用户密码</title>
    <link href="http://yoursite.com/2017/09/08/Changes%20the%20root%20user%20password%20for%20MySQL/"/>
    <id>http://yoursite.com/2017/09/08/Changes the root user password for MySQL/</id>
    <published>2017-09-08T12:00:20.000Z</published>
    <updated>2017-09-19T05:56:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>新安装了MySQL，安装之后粗心把密码给搞丢了，进入MySQL时报错：ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: NO).</p>
<p>通过以下步骤修改密码。</p>
<a id="more"></a>
<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>关闭MySQL服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /usr/local/mysql/support-files/mysql.server stop</div></pre></td></tr></table></figure>
<blockquote>
<p>① 通过DMG安装的MySQL通过’<code>&#39;System Prefrences&#39; &gt; MySQL &gt; &#39;Stop MySQL Server&#39;</code>来结束MySQL服务。</p>
<p>如果报错：ERROR! MySQL server PID file could not be found! 则直接用 ① 的方法关闭即可。</p>
<p>同理打开服务为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span> sudo /usr/local/mysql/support-files/mysql.server start</div><div class="line"><span class="meta">&gt;</span></div></pre></td></tr></table></figure>
</blockquote>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>使用安全模式启动MySQL</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /usr/local/mysql/bin/mysqld_safe --skip-grant-tables</div></pre></td></tr></table></figure>
<h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>在新的Terminal中输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -u root</div></pre></td></tr></table></figure>
<p>在打开的MySQL命令行窗口依次输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UPDATE mysql.user SET authentication_string=PASSWORD(&apos;YOUR_NEW_PASSWORD&apos;) WHERE User=&apos;root&apos;;</div><div class="line">FLUSH PRIVILEGES;</div><div class="line">\q</div></pre></td></tr></table></figure>
<blockquote>
<p>这里注意结尾的 <code>;</code>不能少。</p>
<p><code>YOUR_NEW_PASSWORD</code> 是你的新密码</p>
<p>5.7之前的版本，mysql.user表里面的<code>authentication_string</code>字段改成了：<code>password</code></p>
</blockquote>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>重启MySQL后运行以下命令测试密码是否修改成功</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mysql -u root -p</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新安装了MySQL，安装之后粗心把密码给搞丢了，进入MySQL时报错：ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: NO).&lt;/p&gt;
&lt;p&gt;通过以下步骤修改密码。&lt;/p&gt;
    
    </summary>
    
      <category term="Tutorial" scheme="http://yoursite.com/categories/Tutorial/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Git 快速开始简明教程</title>
    <link href="http://yoursite.com/2017/03/19/The%20introductory%20of%20Git/"/>
    <id>http://yoursite.com/2017/03/19/The introductory of Git/</id>
    <published>2017-03-19T12:18:00.000Z</published>
    <updated>2017-09-19T06:06:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>Git 是一个分布式版本管理系统，即每个终端都有一套完整的项目代码（包括历史文件）。为了使用 Git，先要安装 Git。可以在 Command Line 或者 Terminal 中输入<code>git</code>命令检查是否已经安装。</p>
<a id="more"></a>
<blockquote>
<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2></blockquote>
<h3 id="创建本地工作目录"><a href="#创建本地工作目录" class="headerlink" title="创建本地工作目录"></a>创建本地工作目录</h3><p>先要创建一个文件夹来保存项目代码。例如我使用如下目录：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/Users/renfei/Sites/project</div></pre></td></tr></table></figure>
<p>命令行中<code>cd</code>到这个目录，然后执行<code>git init</code> 命令来初始化：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bogon:~ renfei$ cd /Users/renfei/Sites/project </div><div class="line">bogon:project renfei$ git init</div><div class="line">Initialized empty Git repository in /Users/renfei/Sites/project/.git/</div></pre></td></tr></table></figure>
<h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>使用<code>git remote add</code>命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bogon:buaa-weixin renfei$ git remote add proj https://renfeisong@bitbucket.org/developers/proj.git</div></pre></td></tr></table></figure>
<p>上面的 proj 是一个本地别名，可以起得短一些，以便以后使用。后面的地址则是远程仓库得地址。添加之后，可以使用<code>git remote</code>命令查看当前已有的远程仓库。</p>
<h3 id="从远程仓库得到数据"><a href="#从远程仓库得到数据" class="headerlink" title="从远程仓库得到数据"></a>从远程仓库得到数据</h3><p>使用 <code>git fetch</code> 命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">bogon:project renfei$ git fetch proj</div><div class="line">remote: Counting objects: 39, done.</div><div class="line">remote: Compressing objects: 100% (34/34), done.</div><div class="line">remote: Total 39 (delta 5), reused 0 (delta 0)</div><div class="line">Unpacking objects: 100% (39/39), done.</div><div class="line">From https://bitbucket.org/renfeisong/project</div><div class="line"> * [new branch]      develop    -&gt; proj/develop</div><div class="line"> * [new branch]      master     -&gt; proj/master</div></pre></td></tr></table></figure>
<p>会看到得到了服务器上的文件，以及两个分支，develop 和 master。这里得到得分支数目取决于远程仓库的内容。虽然得到了这些东西，但是现在这些文件还没有出现在你的工作目录中。</p>
<p>这是因为，我们需要利用<code>git checkout</code>命令「检出」（实际就是把工作目录切换到某个分支），才可以看到对应分支下的那些文件。</p>
<h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>使用 <code>checkout</code> 命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bogon:project renfei$ git checkout develop</div><div class="line">Branch develop set up to track remote branch develop from proj.</div><div class="line">Switched to a new branch 'develop'</div></pre></td></tr></table></figure>
<p>例子中我们切换到了 develop 分支，其中对应的文件就都出现了（如果有的话）。</p>
<h2 id="再说分支"><a href="#再说分支" class="headerlink" title="再说分支"></a>再说分支</h2><p>分支是 Git 的一个很重要的功能，因此有必要解释一下。如果把随着时间的推移，代码的变化想象成前进的路线，那么分支就是从路线上的某一点衍生出来的一条支线，在这条支线上的开发不会对原先路线的代码造成任何影响。例如，现在我们有一个 master 分支和一个 develop 分支，master 分支发布稳定版本的应用，而 develop 分支则进行日常开发。一旦达到某个进度节点，develop 分支上的代码足够稳定可以发布，就把 develop 分支合并（merge）到 master 分支，同时继续 develop 分支的开发。</p>
<p>再如，develop 分支开发的过程中出现了某个 bug，一个开发人员想解决这个 bug，那么为了不影响其他人的工作，他可以从 develop 分支再创建一个新的分支 hotfix，然后在这个分支下修改，完成后把它合并回 develop 分支，并删除 hotfix 分支（它的历史使命已经完成）。</p>
<p>可以看出，每个分支都有一套代码。每个开发人员本地都保存了全部分支的全部代码（这些代码连同其他信息被 git 有序地组织在了工作目录下 .git 目录中，这个目录应当是隐藏的），当通过<code>checkout branch_name</code>切换分支时，工作目录下可见的文件也会被切换成当前分支下的文件。而其他分支的文件也并没有丢失，所以非常方便，你可以根据需要切换分支进行不同的工作。</p>
<blockquote>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2></blockquote>
<h3 id="添加新文件"><a href="#添加新文件" class="headerlink" title="添加新文件"></a>添加新文件</h3><p>在工作目录中创建的新文件处于 untracked 状态，即没有被 git 跟踪。新文件不会自动被 git 跟踪，因为许多临时文件、日志文件不需要保存到仓库中。如果要往仓库中添加文件，使用 <code>git add</code> 命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bogon:project renfei$ git add *</div></pre></td></tr></table></figure>
<p>上述做法添加所有文件。如果包含文件夹，则会递归地添加里面的文件。也可以添加单独的文件或者在文件名中使用通配符。</p>
<p>要查看当前状态（哪些文件 untracked，哪些文件处于其他状态等）可以使用 <code>git status</code> 命令。</p>
<p>执行 <code>git add</code> 后，新添加的文件状态（可通过<code>git status</code>查看）变为 change to be committed，或者称为 staged，暂存。意思就是，只要把它 commit 上去就可以了。</p>
<h3 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h3><p>如果修改了某个已跟踪的文件，那么这个文件会变为 modified，not staged，未暂存。此时必须再次 <code>git add</code> 这个文件使它变成 staged 状态，才能够被 commit 上去。</p>
<h3 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h3><p>当有文件状态为暂存的（staged）时，就可以执行 <code>git commit</code> 命令。这个命令会提交暂存的文件。git 要求为每次提交添加一个说明，因此一般使用一个<code>-m</code>选项来添加说明。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">bogon:project renfei$ git commit -m "background admin site (backend) added"</div><div class="line">[develop 7d17136] background admin site (backend) added</div><div class="line"> 16 files changed, 10372 insertions(+)</div><div class="line"> create mode 100644 bootstrap/v2/css/bootstrap-responsive.css</div><div class="line"> create mode 100644 bootstrap/v2/css/bootstrap-responsive.min.css</div><div class="line"> create mode 100644 bootstrap/v2/css/bootstrap.css</div><div class="line"> create mode 100644 bootstrap/v2/css/bootstrap.min.css</div><div class="line"> create mode 100644 bootstrap/v2/img/glyphicons-halflings-white.png</div><div class="line"> create mode 100644 bootstrap/v2/img/glyphicons-halflings.png</div><div class="line"> create mode 100644 bootstrap/v2/js/bootstrap.js</div><div class="line"> create mode 100644 bootstrap/v2/js/bootstrap.min.js</div><div class="line"> create mode 100644 define.php</div><div class="line"> create mode 100644 index.php</div><div class="line"> create mode 100644 jquery/jquery-1.10.2.min.js</div><div class="line"> create mode 100644 login.php</div><div class="line"> create mode 100644 logout.php</div><div class="line"> create mode 100644 pref.php</div><div class="line"> create mode 100644 signup.php</div><div class="line"> create mode 100644 util.php</div></pre></td></tr></table></figure>
<p>这个操作完成后，代码就被提交到了本地仓库。每次进行 commit 后都会对整个项目做一个快照，以后可以随时回滚到某个快照中。</p>
<p>如果希望省略 add 过程而直接提交所有跟踪的文件，可以给 <code>commit</code> 命令加上<code>-a</code>选项。如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bogon:project renfei$ git commit -a -m "background admin site (backend) added"</div></pre></td></tr></table></figure>
<h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><p><code>commit</code>仅仅把更改提交到了本地仓库。如果想推送到远程仓库，需要使用 <code>git push</code> 命令。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">bogon:project renfei$ git push proj develop</div><div class="line">Counting objects: 25, done.</div><div class="line">Delta compression using up to 8 threads.</div><div class="line">Compressing objects: 100% (22/22), done.</div><div class="line">Writing objects: 100% (24/24), 122.16 KiB | 0 bytes/s, done.</div><div class="line">Total 24 (delta 1), reused 0 (delta 0)</div><div class="line">To https://renfeisong@bitbucket.org/renfeisong/project.git</div><div class="line">   d4eeb86..7d17136  develop -&gt; develop</div></pre></td></tr></table></figure>
<p>其中 <code>proj</code> 是之前设定的代号，而 <code>develop</code> 表示推送本地仓库的 <code>develop</code> 分支。</p>
<h3 id="更新本地仓库"><a href="#更新本地仓库" class="headerlink" title="更新本地仓库"></a>更新本地仓库</h3><p>此时，可以随时使用 <code>git pull</code> 命令来从远程仓库拉取更新。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">bogon:project renfei$ git pull</div><div class="line">Already up-to-date.</div></pre></td></tr></table></figure>
<p>如果没有更新，就会显示 <code>Already up-to-date</code>.</p>
<blockquote>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2></blockquote>
<p>Git 还有很多很多功能，比如从仓库移除文件、重命名、比较等。可以参考 Pro Git 这本书，是基于 CC 协议发布的。地址：<a href="http://git-scm.com/book/zh" target="_blank" rel="external">http://git-scm.com/book/zh</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Git 是一个分布式版本管理系统，即每个终端都有一套完整的项目代码（包括历史文件）。为了使用 Git，先要安装 Git。可以在 Command Line 或者 Terminal 中输入&lt;code&gt;git&lt;/code&gt;命令检查是否已经安装。&lt;/p&gt;
    
    </summary>
    
      <category term="Tutorial" scheme="http://yoursite.com/categories/Tutorial/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
      <category term="Terminal" scheme="http://yoursite.com/tags/Terminal/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 配置 Apache, MySQL, PHP 以及 phpMyAdmin 过程记录</title>
    <link href="http://yoursite.com/2017/03/17/The%20process%20of%20configures%20Apache,%20MySQL,%20PHP,%20and%20phpMyAdmin%20at%20Ubuntu/"/>
    <id>http://yoursite.com/2017/03/17/The process of configures Apache, MySQL, PHP, and phpMyAdmin at Ubuntu/</id>
    <published>2017-03-17T06:14:49.000Z</published>
    <updated>2017-09-08T12:14:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install apache2</span></div></pre></td></tr></table></figure>
<p>装好后，配置文件应该位于<code>/etc/apache2</code>中，默认情况下无需修改即可使用。默认的网站目录为<code>/var/www/</code>。</p>
<a id="more"></a>
<p>启动 Apache 的方法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo /etc/init.d/apache2 start</span></div></pre></td></tr></table></figure>
<p>重启 Apache：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo /etc/init.d/apache2 restart</span></div></pre></td></tr></table></figure>
<p>停止 Apache：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo /etc/init.d/apache2 stop</span></div></pre></td></tr></table></figure>
<p>上述命令也可以写成这种形式（以启动为例）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo service apache2 start</span></div></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>装好并启动 Apache 服务后，本地服务器应该就可以用了。可以利用<code>curl</code>访问 localhost 来测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> curl localhost</span></div></pre></td></tr></table></figure>
<p>Apache 的错误日志文件默认为<code>/var/log/apache2/error.log</code>。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>启动的时候可能会出现如下警告：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apache2: Could not determine the server's fully qualified domain name, using 127.0.0.1 for ServerName</div></pre></td></tr></table></figure>
<p>说明你没有指定<code>ServerName</code>。如果想去掉这个错误，可以修改<code>/etc/apache2/apache2.conf</code>文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo vi /etc/apache2/apache2.conf</span></div></pre></td></tr></table></figure>
<p>添加如下行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ServerName localhost</div></pre></td></tr></table></figure>
<blockquote>
<h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2></blockquote>
<h3 id="安装-PHP"><a href="#安装-PHP" class="headerlink" title="安装 PHP"></a>安装 PHP</h3><p>同样使用<code>apt-get</code>命令安装 PHP：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install php5</span></div></pre></td></tr></table></figure>
<p>执行之后，PHP 应该就已经部署完毕了。可以使用<code>phpinfo()</code>函数来测试 PHP 是否已经就绪：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo vi /var/www/phpinfo.php</span></div></pre></td></tr></table></figure>
<p>在文件里输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;?php phpinfo(); ?&gt;</div></pre></td></tr></table></figure>
<p>然后<code>curl localhost/phpinfo.php</code>来查看。</p>
<h3 id="安装其他-PHP-模块"><a href="#安装其他-PHP-模块" class="headerlink" title="安装其他 PHP 模块"></a>安装其他 PHP 模块</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install php5-mysql php5-curl php5-gd php5-intl php-pear php5-imagick php5-imap php5-mcrypt php5-memcache php5-ming php5-ps php5-pspell php5-recode php5-snmp php5-sqlite php5-tidy php5-xmlrpc php5-xsl</span></div></pre></td></tr></table></figure>
<blockquote>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2></blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install mysql-server</span></div></pre></td></tr></table></figure>
<p>安装过程中需要设定 root 账户的密码。至此，LAMP 环境已经配好。</p>
<blockquote>
<h2 id="phpMyAdmin"><a href="#phpMyAdmin" class="headerlink" title="phpMyAdmin"></a>phpMyAdmin</h2></blockquote>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>首先执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install phpmyadmin</span></div></pre></td></tr></table></figure>
<p>安装过程比较长，会有几个选项，依次如下：</p>
<p>（1）选择服务器软件。这里选择刚刚安装的 Apache2。</p>
<p>（2）选择手动设定。</p>
<p>（3）输入之前安装 MySQL 时设的 MySQL root 账户的密码。</p>
<p>（4）设定 phpMyAdmin 的登录密码。</p>
<p>注意，phpMyAdmin 的配置文件为：<code>/etc/phpmyadmin/config.inc.php</code>。</p>
<h3 id="包含-pma-的配置文件到-Apache"><a href="#包含-pma-的配置文件到-Apache" class="headerlink" title="包含 pma 的配置文件到 Apache"></a>包含 pma 的配置文件到 Apache</h3><p>安装后，还不能立即使用 phpMyAdmin，因为它不在网站目录下。为了正常使用，只需把 phpMyAdmin 的配置文件包含到 Apache 的配置中。编辑<code>apache2.conf</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo vi /etc/apache2/apache2.conf</span></div></pre></td></tr></table></figure>
<p>在文件中添加如下行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Include /etc/phpmyadmin/apache.conf</div></pre></td></tr></table></figure>
<p>重启服务器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo service apache2 restart</span></div></pre></td></tr></table></figure>
<p>至此，你就可以通过<code>yourdomain/phpmyadmin</code>来访问 phpMyAdmin 了。</p>
<h3 id="mcrypt-模块丢失的错误"><a href="#mcrypt-模块丢失的错误" class="headerlink" title="mcrypt 模块丢失的错误"></a>mcrypt 模块丢失的错误</h3><p>一个 bug 可能导致访问 phpMyAdmin 时出现 mcrypt 模块丢失的错误。如果遇到，则可以采用下面的办法修复：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo ln -s /etc/php5/conf.d/mcrypt.ini /etc/php5/mods-available/</span></div><div class="line"><span class="meta">$</span><span class="bash"> sudo php5enmod mcrypt</span></div><div class="line"><span class="meta">$</span><span class="bash"> sudo service apache2 restart</span></div></pre></td></tr></table></figure>
<blockquote>
<h2 id="全局禁用-Index"><a href="#全局禁用-Index" class="headerlink" title="全局禁用 Index"></a>全局禁用 Index</h2></blockquote>
<p>Index 就是访问一个不存在 index.html、index.php 等文件的目录时服务器列出的文件列表，这样会对用户展示文件结构，如果想禁用，可以修改 Apache 的配置文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">$</span><span class="bash"> sudo vi /etc/apache2/apache2.conf</span></div></pre></td></tr></table></figure>
<p>找到并修改为</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;Directory /var/www/&gt;</div><div class="line">        Options -Indexes</div><div class="line">        Options FollowSymLinks</div><div class="line">        AllowOverride None</div><div class="line">        Require all granted</div><div class="line">&lt;/Directory&gt;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Apache&quot;&gt;&lt;a href=&quot;#Apache&quot; class=&quot;headerlink&quot; title=&quot;Apache&quot;&gt;&lt;/a&gt;Apache&lt;/h2&gt;&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; sudo apt-get install apache2&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;装好后，配置文件应该位于&lt;code&gt;/etc/apache2&lt;/code&gt;中，默认情况下无需修改即可使用。默认的网站目录为&lt;code&gt;/var/www/&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Tutorial" scheme="http://yoursite.com/categories/Tutorial/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="Ubuntu" scheme="http://yoursite.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>C++ string 字符串函数详解</title>
    <link href="http://yoursite.com/2017/03/17/The%20details%20of%20string%20function%20of%20Cpp/"/>
    <id>http://yoursite.com/2017/03/17/The details of string function of Cpp/</id>
    <published>2017-03-17T06:07:34.000Z</published>
    <updated>2017-10-12T08:08:12.306Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2></blockquote>
<ol>
<li><p>+ 和 +=：连接字符串</p>
</li>
<li><p>=：字符串赋值</p>
</li>
<li><p>>、&gt;=、&lt; 和 &lt;=：字符串比较（例如a &lt; b, aa &lt; ab）</p>
</li>
<li><p>==、!=：比较字符串</p>
</li>
<li><p>&lt;&lt;、&gt;&gt;：输出、输入字符串</p>
<a id="more"></a>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">	<span class="built_in">string</span> str = <span class="string">"cat"</span>;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"apple"</span> + <span class="string">"boy"</span> + str; <span class="comment">// illegal!</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2></blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">string</span> str;</div><div class="line"><span class="built_in">cin</span> &gt;&gt; str;</div><div class="line"></div><div class="line">str.find(<span class="string">"ab"</span>);<span class="comment">//返回字符串 ab 在 str 的位置</span></div><div class="line">str.find(<span class="string">"ab"</span>, <span class="number">2</span>);<span class="comment">//在 str[2]~str[n-1] 范围内查找并返回字符串 ab 在 str 的位置</span></div><div class="line">str.rfind(<span class="string">"ab"</span>, <span class="number">2</span>);<span class="comment">//在 str[0]~str[2] 范围内查找并返回字符串 ab 在 str 的位置</span></div><div class="line"></div><div class="line"><span class="comment">//first 系列函数</span></div><div class="line">str.find_first_of(<span class="string">"apple"</span>);<span class="comment">//返回 apple 中任何一个字符首次在 str 中出现的位置</span></div><div class="line">str.find_first_of(<span class="string">"apple"</span>, <span class="number">2</span>);<span class="comment">//返回 apple 中任何一个字符首次在 str[2]~str[n-1] 范围中出现的位置</span></div><div class="line">str.find_first_not_of(<span class="string">"apple"</span>);<span class="comment">//返回除 apple 以外的任何一个字符在 str 中首次出现的位置</span></div><div class="line">str.find_first_not_of(<span class="string">"apple"</span>, <span class="number">2</span>);<span class="comment">//返回除 apple 以外的任何一个字符在 str[2]~str[n-1] 范围中首次出现的位置</span></div><div class="line"></div><div class="line"><span class="comment">//last 系列函数</span></div><div class="line">str.find_last_of(<span class="string">"apple"</span>);<span class="comment">//返回 apple 中任何一个字符最后一次在 str 中出现的位置</span></div><div class="line">str.find_last_of(<span class="string">"apple"</span>, <span class="number">2</span>);<span class="comment">//返回 apple 中任何一个字符最后一次在 str[0]~str[2] 范围中出现的位置</span></div><div class="line">str.find_last_not_of(<span class="string">"apple"</span>);<span class="comment">//返回除 apple 以外的任何一个字符在 str 中最后一次出现的位置</span></div><div class="line">str.find_last_not_of(<span class="string">"apple"</span>, <span class="number">2</span>);<span class="comment">//返回除 apple 以外的任何一个字符在 str[0]~str[2] 范围中最后一次出现的位置</span></div><div class="line"></div><div class="line"><span class="comment">//以上函数如果没有找到，均返回string::npos</span></div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>::npos;</div></pre></td></tr></table></figure>
<blockquote>
<h2 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h2></blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">str.substr(<span class="number">3</span>); <span class="comment">//返回 [3] 及以后的子串</span></div><div class="line">str.substr(<span class="number">2</span>, <span class="number">4</span>); <span class="comment">//返回 str[2]~str[2+(4-1)] 子串(即从[2]开始4个字符组成的字符串)</span></div></pre></td></tr></table></figure>
<blockquote>
<h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2></blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">str.replace(<span class="number">2</span>, <span class="number">4</span>, <span class="string">"sz"</span>);<span class="comment">//返回把 [2]~[2+(4-1)] 的内容替换为 "sz" 后的新字符串</span></div><div class="line">str.replace(<span class="number">2</span>, <span class="number">4</span>, <span class="string">"abcd"</span>, <span class="number">3</span>);<span class="comment">//返回把 [2]~[2+(4-1)] 的内容替换为 "abcd" 的前3个字符后的新字符串</span></div></pre></td></tr></table></figure>
<blockquote>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2></blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">str.insert(<span class="number">2</span>, <span class="string">"sz"</span>);<span class="comment">//从 [2] 位置开始添加字符串 "sz"，并返回形成的新字符串</span></div><div class="line">str.insert(<span class="number">2</span>, <span class="string">"abcd"</span>, <span class="number">3</span>);<span class="comment">//从 [2] 位置开始添加字符串 "abcd" 的前 3 个字符，并返回形成的新字符串</span></div><div class="line">str.insert(<span class="number">2</span>, <span class="string">"abcd"</span>, <span class="number">1</span>, <span class="number">3</span>);<span class="comment">//从 [2] 位置开始添加字符串 "abcd" 的前 [2]~[2+(3-1)] 个字符，并返回形成的新字符串</span></div></pre></td></tr></table></figure>
<blockquote>
<h2 id="追加"><a href="#追加" class="headerlink" title="追加"></a>追加</h2></blockquote>
<p>除了用重载的 <code>+</code> 操作符，还可以使用函数来完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">str.push_back(<span class="string">'a'</span>);<span class="comment">//在 str 末尾添加字符'a'</span></div><div class="line">str.append(<span class="string">"abc"</span>);<span class="comment">//在 str 末尾添加字符串"abc"</span></div></pre></td></tr></table></figure>
<blockquote>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2></blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">str.erase(<span class="number">3</span>);<span class="comment">//删除 [3] 及以后的字符，并返回新字符串</span></div><div class="line">str.erase(<span class="number">3</span>, <span class="number">5</span>);<span class="comment">//删除从 [3] 开始的 5 个字符，并返回新字符串</span></div></pre></td></tr></table></figure>
<blockquote>
<h2 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h2></blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">str1.swap(str2);<span class="comment">//把 str1 与 str2 交换</span></div></pre></td></tr></table></figure>
<blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2></blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">str.size();<span class="comment">//返回字符串长度</span></div><div class="line">str.length();<span class="comment">//返回字符串长度</span></div><div class="line">str.empty();<span class="comment">//检查 str 是否为空，为空返回 1，否则返回 0</span></div><div class="line">str[n];<span class="comment">//存取 str 第 n + 1 个字符</span></div><div class="line">str.at(n);<span class="comment">//存取 str 第 n + 1 个字符（如果溢出会抛出异常）</span></div></pre></td></tr></table></figure>
<blockquote>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2></blockquote>
<h3 id="查找给定字符串并把相应子串替换为另一给定字符串"><a href="#查找给定字符串并把相应子串替换为另一给定字符串" class="headerlink" title="查找给定字符串并把相应子串替换为另一给定字符串"></a>查找给定字符串并把相应子串替换为另一给定字符串</h3><p>string 并没有提供这样的函数，所以我们自己来实现。由于给定字符串可能出现多次，所以需要用到 <code>find()</code> 成员函数的第二个参数，每次查找之后，从找到位置往后继续搜索。直接看代码（这个函数返回替换的次数，如果返回值是 0 说明没有替换）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">str_replace</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="keyword">const</span> <span class="built_in">string</span> &amp;src, <span class="keyword">const</span> <span class="built_in">string</span> &amp;dest)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">    <span class="built_in">string</span>::size_type pos = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> ((pos = str.find(src, pos)) != <span class="built_in">string</span>::npos) &#123;</div><div class="line">        str.replace(pos, src.size(), dest);</div><div class="line">        ++counter;</div><div class="line">        pos += dest.size();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> counter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="从给定字符串中删除一给定字串"><a href="#从给定字符串中删除一给定字串" class="headerlink" title="从给定字符串中删除一给定字串"></a>从给定字符串中删除一给定字串</h3><p>方法和上面相似，内部使用 <code>erase()</code> 完成。代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">str_erase</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="keyword">const</span> <span class="built_in">string</span> src)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">    <span class="built_in">string</span>::size_type pos = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> ((pos = str.find(src, pos)) != <span class="built_in">string</span>::npos) &#123;</div><div class="line">        str.erase(pos, src.size());</div><div class="line">        ++counter;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> counter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="给定一字符串和一字符集，从字符串剔除字符集中的任意字符"><a href="#给定一字符串和一字符集，从字符串剔除字符集中的任意字符" class="headerlink" title="给定一字符串和一字符集，从字符串剔除字符集中的任意字符"></a>给定一字符串和一字符集，从字符串剔除字符集中的任意字符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">str_wash</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="keyword">const</span> <span class="built_in">string</span> src)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</div><div class="line">    <span class="built_in">string</span>::size_type pos = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> ((pos = str.find_first_of(src, pos)) != <span class="built_in">string</span>::npos) &#123;</div><div class="line">        str.erase(pos, <span class="number">1</span>);</div><div class="line">        ++counter;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> counter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h2 id=&quot;运算符重载&quot;&gt;&lt;a href=&quot;#运算符重载&quot; class=&quot;headerlink&quot; title=&quot;运算符重载&quot;&gt;&lt;/a&gt;运算符重载&lt;/h2&gt;&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;+ 和 +=：连接字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;=：字符串赋值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&gt;、&amp;gt;=、&amp;lt; 和 &amp;lt;=：字符串比较（例如a &amp;lt; b, aa &amp;lt; ab）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;==、!=：比较字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&amp;lt;&amp;lt;、&amp;gt;&amp;gt;：输出、输入字符串&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS X Terminal 101：终端使用初级教程</title>
    <link href="http://yoursite.com/2017/03/17/The%20introductory%20of%20macOS%20Terminal/"/>
    <id>http://yoursite.com/2017/03/17/The introductory of macOS Terminal/</id>
    <published>2017-03-17T06:07:34.000Z</published>
    <updated>2017-09-08T12:17:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习苹果认证的《Mac OS X Support Essentials》教程，看到 Command Line 一节有很多实用的知识，下面选取一部分翻译 + 笔记，整理成此文。</p>
<a id="more"></a>
<blockquote>
<p>你可以整天驾驶汽车而不用知道如何修理它们，但是如果你希望当一个维护员，你就需要知道事情是如何运作的。同样的事情也发生在了 Mac OS X 上；你可以一直使用 Mac 而不用知道如何修理它，但是如果你想对系统做一些维护或解决一些问题，那么你需要知道如何使用 command-line。</p>
<h2 id="为什么要使用命令行-如何开启命令行？"><a href="#为什么要使用命令行-如何开启命令行？" class="headerlink" title="为什么要使用命令行/如何开启命令行？"></a>为什么要使用命令行/如何开启命令行？</h2></blockquote>
<ul>
<li>许多功能在图形界面不提供，只有通过命令行来实现。</li>
<li>Finder会隐藏许多你不太会需要的文件，然而 command line 会允许你访问所有文件。</li>
<li>通过 command line 可以远程访问你的 Mac（利用 SSH）。</li>
<li>administrators 用户可以通过 <code>sudo</code> 命令获得 root 用户权限。</li>
<li>通过 command-line script 可以使工作更高效。</li>
<li>Terminal（终端）程序可以在“实用工具”里找到。</li>
<li>如果你开启手动输入用户名登陆模式，登陆时在用户名处输入 <code>&gt;console</code> 可以直接进入命令行界面。随后你仍然需要登录到一个账户。</li>
</ul>
<blockquote>
<h2 id="初识Command-Line"><a href="#初识Command-Line" class="headerlink" title="初识Command Line"></a>初识Command Line</h2></blockquote>
<ul>
<li><p>许多命令会花费一些时间来执行，然而这中间不会给出任何提示或者进度条。一般结束后会出现一个“用户名$”的标记。如果没有出现，那么说明最后一条命令正在执行。</p>
</li>
<li><p>一条命令包括 Command Name、Options、Arguments、Extras 四个部分，但是后三个部分有时是可选的。Options 部分用<code>-</code>作为前导符。其中许多命令的 Options 部分只包含单个字母，这时可以合并。例如，<code>ls -lA</code>和<code>ls -l -A</code>是等效的。Arguments 部分用来细化这个命令或指定这个命令具体的实施对象，Extras 部分则用来进一步实现其他功能。</p>
</li>
<li><p>举例：下列命令包含前三个部分，用于删除 Junk 这个程序。</p>
<p><code>michelle$ rm -R /Applications/Junk.app</code></p>
</li>
<li><p>如果你输入了一些错误的命令，系统会返回一些错误信息。但是系统却不会阻止你做傻事（例如删除整个用户文件夹）。</p>
</li>
</ul>
<blockquote>
<h2 id="关于-man-命令"><a href="#关于-man-命令" class="headerlink" title="关于 man 命令"></a>关于 man 命令</h2></blockquote>
<p>虽然有上千条命令，每条命令还有许多可选参数和具体的使用方式，但是你却不需要记住这些命令。你只需要记住一个：<code>man</code></p>
<p>大多数命令都会包含一个使用指南，会告诉你任何你需要知道的关于这个命令的所有细节，在命令行中输入 <code>man command-name</code> 即可获取。例如，你想知道<code>ls</code>这个命令怎么使用，输入<code>man ls</code>即可进入使用指南页面。</p>
<p>使用指南往往很长，所以你可以使用▲（上箭头）或▼（下箭头）来上下移动，使用 Speace 来翻页，输入<code>/</code>和关键字来按照关键字搜索，按Q来退出使用指南页面。</p>
<p>那么——如果你连命令名称都不知道怎么办呢？输入<code>man -k</code>和关键字来对整个使用指南数据库进行搜索。</p>
<blockquote>
<h2 id="命令行，文件和路径"><a href="#命令行，文件和路径" class="headerlink" title="命令行，文件和路径"></a>命令行，文件和路径</h2><p>如果知道如何使用命令是掌握 command line 的第一步，那么第二步就是学习如何在 command line 中使用文件路径。如果你掌握了文件路径，你将会发现这比使用 Finder 更加快捷。</p>
</blockquote>
<p><strong>注意</strong></p>
<ul>
<li>command line 工具是大小写敏感的，并且对于文件名，必须包括扩展名。例如，你想找iTunes这个程序，输入<code>itunes</code>是无效的，必须输入<code>iTunes.app</code>。</li>
<li>Mac OS传统上喜欢使用“文件夹”（folders）这个名称，但是在 command line 中，主要使用“目录”（directory）这个词。这和 UNIX 是一致的。</li>
</ul>
<h3 id="两种路径：绝对路径和相对路径"><a href="#两种路径：绝对路径和相对路径" class="headerlink" title="两种路径：绝对路径和相对路径"></a>两种路径：绝对路径和相对路径</h3><ul>
<li>绝对路径：完整描述一个文件的位置，总是以斜杠（<code>/</code>）（forward slash）开头。例如<code>/Users/michelle/Public/Drop Box</code>。</li>
<li>相对路径：只描述一部分位置信息，它和你在 command line 目前的目录有关。当你打开新的 Terminal 程序时，command line 会话的目录应该是你的 home folder。这时上面例子文件夹的相对路径写作<code>Public/Drop Box</code>。显然它从当前目录开始。和html类似，你也可以使用两个点（“<code>..</code>”）来代表父目录，这样你就可以用相对路径表示上级或同级目录了。例如你可以输入<code>cd ..</code>甚至<code>cd ../..</code></li>
</ul>
<h3 id="切换到其他路径和目录"><a href="#切换到其他路径和目录" class="headerlink" title="切换到其他路径和目录"></a>切换到其他路径和目录</h3><p>如果你想将当前 command line 会话切换到其他目录，需要用到三个命令：<code>pwd</code>，<code>ls</code>和<code>cd</code>。</p>
<ol>
<li><code>pwd</code>的含义是“print working directory”，会显示当前目录的绝对路径。</li>
<li><code>ls</code>的含义是“list directory contents”，它会列出当前目录的内容。这个命令还有其他参数可选。</li>
<li><code>cd</code>的含义是“change directory”，它会改变当前目录到你指定的目录。如果你不指定，则会返回你的 home folder。</li>
</ol>
<h3 id="处理特殊字符"><a href="#处理特殊字符" class="headerlink" title="处理特殊字符"></a>处理特殊字符</h3><p>如果目录中有特殊字符（空格，括号，引号，<code>[]</code>，<code>!</code>，<code>$</code>，<code>&amp;</code>，<code>*</code>，<code>;</code>，<code>|</code>，<code>\</code>），那么直接输入空格会造成系统识别困难，必须使用特殊的语法来表示这些字符。例如上例中，空格前添加反斜杠“<code>\</code>”（back slash）即可：<code>cd Punlic/Drop\ Box/</code>。除了反斜杠，也可以用引号的方法：<code>cd &quot;Public/Drop Box&quot;。</code></p>
<p>——如果不想手动输入，也可以把文件从 Finder 拖到 Terminal 窗口来创建绝对路径，这会方便一些，因为上面提到的所有特殊字符在拖动后都会自动变成系统可识别的表示方法。其实，更有效率的解决方案是使用 Tab Complete 功能。</p>
<p>Tab Complete 是 command line 中最能给你节省时间的特性之一，利用它的自动完成文件、目录名称功能还可以防止你输入错误。使用<code>cd</code>进入你的 home folder，使用<code>cd P</code>命令，然后按下tab按键。你可能会听到错误音，因为你的 home folder 内有多个 P 开头的文件夹。再按一次tab，Terminal 将会为你列出 P 开头的两个文件夹：Public 和 Pictures。按U，再按tab，Terminal 则会自动为你补全<code>Public/</code>。Tab complete 同样会处理那些特殊字符。注意，这会在末尾保留<code>/</code>符号，大部分时候这没问题，但如果出错，移除多余的<code>/</code>试一试。</p>
<p>另外，鄂化符<code>~</code>（tilde）在command line 中可以代表当前用户的 home folder。例如<code>~/Public/Drop\ Box/</code>是合法的。</p>
<h3 id="查看隐藏文件"><a href="#查看隐藏文件" class="headerlink" title="查看隐藏文件"></a>查看隐藏文件</h3><p>为了简化工作，command line 和 Finder 都会隐藏许多文件和文件夹，这些内容通常是系统需要的。不借助第三方工具让 Finder 显示隐藏文件比较困难，但是在 command line 中却非常简单。首先，许多隐藏文件的隐藏是通过隐藏属性在 Finder 中隐藏的，而 command line 会忽略这些属性，所以这些文件会在 command line 中显示。另外，<code>ls</code>命令会隐藏文件名以<code>.</code>开头的文件，但是这些文件却可以被显示出来，方法是利用<code>-a</code>选项。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">michelle$</span><span class="bash"> ls -la</span></div></pre></td></tr></table></figure>
<p>我们还添加了<code>-l</code>选项，目的是控制输出格式。如果你注意输出内容的话，会发现还包括<code>.</code>和<code>..</code>两项，它们分别表示当前文件夹和父文件夹（如图）。如果你不想显示这两项，只需要把<code>-a</code>改成<code>-A</code>即可。</p>
<p><img src="/2017/03/17/The introductory of macOS Terminal/Users/sephiroth/Downloads/terminal729.png" alt="terminal729"></p>
<h3 id="前往其他卷"><a href="#前往其他卷" class="headerlink" title="前往其他卷"></a>前往其他卷</h3><p>在 command line 中，系统卷（也称为 root volume）是由开始的一个正斜杠表示的。然而也许听起来不可思议，在 command line 中其他卷看起来就在文件系统中一个叫做 Volumes 的文件夹中。下面的命令清晰地显示出这种逻辑关系：我从我的 home folder 出发，最终前往一个叫 Time Machine 的卷，该卷是外接在 Mac 上的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">bogon:~ renfei$ pwd</div><div class="line">/Users/renfei</div><div class="line">bogon:~ renfei$ cd /Volumes/</div><div class="line">bogon:Volumes renfei$ pwd</div><div class="line">/Volumes</div><div class="line">bogon:Volumes renfei$ ls</div><div class="line">Macintosh SSD &amp;nbsp; &amp;nbsp; &amp;nbsp;Time Machine</div><div class="line">bogon:Volumes renfei$ cd Time\ Machine/</div><div class="line">bogon:Time Machine renfei$ pwd</div><div class="line">/Volumes/Time Machine</div></pre></td></tr></table></figure>
<h2 id="用Command-Line管理文件"><a href="#用Command-Line管理文件" class="headerlink" title="用Command-Line管理文件"></a>用Command-Line管理文件</h2><h3 id="检视文件"><a href="#检视文件" class="headerlink" title="检视文件"></a>检视文件</h3><p>有许多基础命令用来定位、检视文件和文件夹，包括<code>cat</code>, <code>less</code>, <code>which</code>, <code>file</code>以及<code>find</code>。别忘了，你可以利用<code>man</code>命令来查阅每个命令的使用指南。</p>
<h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p><code>cat</code>是“concatenate”的意思，会按顺序读取文件并输出到 Terminal 窗口，语法为<code>cat</code>后接你需要查看的文件的路径。<code>cat</code>命令也可以用<code>&gt;&gt;</code>来增加文本文件的内容，例如命令<code>cat ../textOne.txt &gt;&gt; textTwo.txt</code>会把 textOne.txt 的内容添加到 textTwo.txt 的结尾。这个<code>&gt;&gt;</code>就属于上一篇提到的“Extras”。</p>
<h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><p>这个命令更适合用来查看长文本文件，因为它会允许你查找文本。语法为 <code>less</code>后接文件路径，和<code>cat</code>一样。用<code>less</code>命令打开的文件其实和你查看命令使用指南的时候使用的是一个查看器，所以操作是相同的，同样可以使用▲（上箭头）或▼（下箭头）来上下移动文本，使用 空格 来翻页，输入<code>/</code>和关键字来按照关键字搜索，按Q来退出使用指南页面。除此之外，按V键来使用<code>vi</code>文本编辑器。</p>
<h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><p>这个命令会定位某个命令的文件路径。换言之，它会告诉你你执行某个具体命令的时候，在使用哪个文件。语法为<code>which</code>后接某个命令。如图：</p>
<p><img src="/2017/03/17/The introductory of macOS Terminal/Users/sephiroth/Downloads/屏幕快照-2012-07-29-13.53.59.png" alt="屏幕快照-2012-07-29-13.53.59"></p>
<h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p>这个命令会尝试根据文件的内容输出文件类型。如果一个文件缺失了扩展名，那么这个命令可能会非常有用。语法为<code>file</code>后接文件路径。如图，此例为一个 PNG 文件，还给出了它的尺寸、颜色数等信息。</p>
<p><img src="/2017/03/17/The introductory of macOS Terminal/Users/sephiroth/Downloads/屏幕快照-2012-07-29-14.04.51.png" alt="屏幕快照-2012-07-29-14.04.51"></p>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>这个命令用来根据搜索关键词定位文件路径。 <code>find</code>命令不使用 Spotlight 搜索服务，但是它允许你设置非常具体的搜索条件，以及通配符（稍后介绍）。语法为<code>find</code>后接搜索的起始路径，后接定义搜索的选项，后接搜索内容（包含在引号里）。例如：</p>
<p><img src="/2017/03/17/The introductory of macOS Terminal/Users/sephiroth/Downloads/屏幕快照-2012-07-29-14.12.49.png" alt="屏幕快照-2012-07-29-14.12.49"></p>
<p><strong>注意</strong></p>
<ol>
<li>如果你要搜索根目录，也许你想使用<code>-x</code>选项来避免搜索 /Volumes 文件夹。</li>
<li>如果想使用 Soptlight 搜索服务，使用<code>mdfind</code>命令后接搜索关键词即可。</li>
</ol>
<h3 id="使用通配符（Wildcard-Characters）"><a href="#使用通配符（Wildcard-Characters）" class="headerlink" title="使用通配符（Wildcard Characters）"></a>使用通配符（Wildcard Characters）</h3><p>下面是常用的通配符：</p>
<ul>
<li>星号（＊，Asterisk）——代表任何长度的任何字符。例如<code>*.tiff</code>代表所有格式为tiff的文件。</li>
<li>问号（?，Question mark）——代表任何单个字符。例如<code>b?ok</code>匹配 book 但是不匹配 brook。</li>
<li>方括号（[]，Square brackets）——定义一定范围的字符，例如<code>[Dd]ocument</code>匹配 Document 以及 document；<code>doc[1-9]</code>匹配doc1, doc2, …, doc9。</li>
</ul>
<p>配合使用上面三种通配符可以大大提高效率。</p>
<h3 id="使用递归命令"><a href="#使用递归命令" class="headerlink" title="使用递归命令"></a>使用递归命令</h3><p>简单来说，递归命令可以允许命令不执行于一个特定文件，而是指定的路径下的所有文件。大多数命令包含一个<code>-r</code>或者<code>-R</code>选项，来设定你想递归地执行这个命令。例如下面的例子，展示了添加<code>-R</code>后<code>ls</code>命令的执行方式：</p>
<p><img src="/2017/03/17/The introductory of macOS Terminal/Users/sephiroth/Downloads/屏幕快照-2012-07-29-14.39.00.png" alt="屏幕快照-2012-07-29-14.39.00"></p>
<h3 id="编辑文件和文件夹"><a href="#编辑文件和文件夹" class="headerlink" title="编辑文件和文件夹"></a>编辑文件和文件夹</h3><p>有许多基础的命令用来编辑文件和文件夹，包括<code>mkdir</code>, <code>cp</code>, <code>mv</code>, <code>rm</code>, <code>rmdir</code>以及<code>vi</code>。下面我们来简要地介绍一下这些命令。</p>
<h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p>“make diretory”的缩写，用来创建文件夹，语法为<code>mkdir</code>后接新文件夹的目录。可以用<code>-p</code>选项，来一起创建路径中不存在的文件夹（这样你就不用挨层创建了）。</p>
<h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>“copy”的缩写，用来把文件从一处复制到另一处。语法为<code>cp</code>后接原始路径，后接目标路径。如果你想复制整个文件夹和所有内容，需要添加<code>-R</code>选项。如果指定的目标路径不含文件名，则 cp 命令会按原名复制。如果指定的目标路径包括文件名，则会复制为你指定的文件名。如果仅指定新文件名，则会在原处以新名称创建文件副本。注意，系统会自动替换同名文件而不出现提示。</p>
<h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>“move”的缩写，用来移动文件。语法为<code>mv</code>后接原路径，后接新路径。mv 的指定路径规则和 cp 是一样的（没错，如果仅指定新文件名，它就成了重命名命令）。</p>
<h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>“remove”的缩写，会永久删除文件。注意，command-line中没有废纸篓。语法为<code>rm</code>后接文件路径。然而，使用 rm 命令删除的文件有可能可以通过数据恢复工具恢复。如果希望安全删除文件，可以使用<code>srm</code>命令。</p>
<h4 id="rmdir和rm-R"><a href="#rmdir和rm-R" class="headerlink" title="rmdir和rm -R"></a>rmdir和rm -R</h4><p>rmdir是“remove directory”的缩写，这个命令会永久删除文件夹。再强调一遍，CLI 中木有废纸篓。语法为<code>rmdir</code>后接希望删除目录的路径。然而，rmdir 命令无法删除含有任何其他文件的文件夹，所以大多数情形下<code>rmdir</code>命令是不适用的。不过，你可以利用<code>rm</code>添加<code>-R</code>选项来删除文件夹及包含的所有文件。</p>
<h4 id="vi"><a href="#vi" class="headerlink" title="vi"></a>vi</h4><p>代表“visual”（视觉的），然而这个名称相当具有讽刺意味：vi可能是可视化效果最差的文本编辑器了。然而，vi 是 command line 中最常见的文本编辑器。用vi打开文本文件，只需要输入<code>vi</code>后接文件路径即可。Mac OS X 还提供了<code>nano</code>，一个更加现代的文本编辑器。它也更加方便，例如在底部包含了一个作弊小条（=_=），上面有常用的快捷键列表（你就不用背下来它们了）。然而，vi却有时是默认的文本编辑器，所以掌握vi是很有用的。</p>
<p>和<code>less</code>命令类似，<code>vi</code>命令会占用整个 Terminal 空间来显示文件内容。打开后，在“command模式”，vi 会等你输入一些预定义字符来告诉 vi 你想做什么。你也可以使用键盘上的箭头键单纯地浏览文件。你想编辑时，按A开始（会进入编辑模式）。文字会插入到光标处。如果你想保存，需要先退出编辑模式进入 command 模式。方法是按下esc键。回到 command 模式后，按住shift同时按两次Z来保存并退出。如果你不想保存，在 command 模式输入<code>:quit!</code>并按 enter/return 直接退出。</p>
<blockquote>
<h2 id="用Command-Line管理系统"><a href="#用Command-Line管理系统" class="headerlink" title="用Command-Line管理系统"></a>用Command-Line管理系统</h2></blockquote>
<h3 id="使用su来切换用户"><a href="#使用su来切换用户" class="headerlink" title="使用su来切换用户"></a>使用su来切换用户</h3><p><code>su</code>命令代表“substitute user identity”，允许你在命令行中轻松切换到另一个用户账户。语法为<code>su</code>后接用户的短名称。然后会要求你输入密码（但是输入的时候不会显示）。执行完毕后，命令的前缀会改变，表示你拥有其他用户的权利。你可以利用<code>who -m</code>命令来验证当前登陆的身份。切换后，你会一直保持该用户身份，直至退出 Terminal 或者输入<code>exit</code>命令。</p>
<h3 id="关于sudo的使用"><a href="#关于sudo的使用" class="headerlink" title="关于sudo的使用"></a>关于sudo的使用</h3><h4 id="sudo概述"><a href="#sudo概述" class="headerlink" title="sudo概述"></a>sudo概述</h4><p>更强大的命令就是<code>sudo</code>，代表“substitute user do”，或者，更恰当地，“super user do”。用<code>sudo</code>执行一个命令会使用 root 账户权限。当然，使用之前需要 administrator 账户（管理员账户）的授权（如输入密码）。</p>
<p>默认情况下，任何管理员账户都可以使用<code>sudo</code>来获取 root 权限，甚至当 root 账户在图形界面被禁用的情况下，<code>sudo</code>依然有效。这个命令是很多情况下我们不得不使用 Terminal 的原因，——同样也是给每个用户管理员身份的危险所在。不过，你可以调整<code>sudo</code>的配置文件，来限制它的使用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">bogon:~ renfei$ cat secret.txt</div><div class="line">cat: secret.txt: Permission denied</div><div class="line">bogon:~ renfei$ sudo cat secret.txt</div><div class="line">Password:</div><div class="line">This is the contents of the secret.txt text file that the user account renfei does not normally have access permissions to read. However, because he is an administrative user, she can use the sudo command to envoke root user access and read the contents of this file.</div></pre></td></tr></table></figure>
<p><strong>提示</strong>：如果由于你忘了使用<code>sudo</code>而导致命令行返回一个错误，只需输入<code>sudo !!</code>就可以用<code>sudo</code>来执行上一条指令。</p>
<p>记住，权力越大责任越大。不恰当地使用<code>sudo</code>可以轻易破坏你的系统设置。命令行只会在你第一次执行严重破坏性行为之前提示你，之后，它就会假设你清楚自己正在干什么。如果你只掌握三条使用命令行的准则，那将是：总是仔细检查你的命令；总是使用Tab completion来帮助你避免拼写错误；使用<code>sudo</code>之前，总是仔仔细细检查你的命令。</p>
<h4 id="使用-sudo-切换-Shell"><a href="#使用-sudo-切换-Shell" class="headerlink" title="使用 sudo 切换 Shell"></a>使用 sudo 切换 Shell</h4><p>如果你是一个管理员用户，你需要执行很多条需要 root 权限的命令，你可以临时切换整个命令行 shell 来取得 root 级别的访问权限。方法就是先输入<code>sudo -s</code>，回车后再键入你的密码。</p>
<blockquote>
<h2 id="其他Command-Line技巧提示"><a href="#其他Command-Line技巧提示" class="headerlink" title="其他Command-Line技巧提示"></a>其他Command-Line技巧提示</h2></blockquote>
<ul>
<li>输入命令<code>open .</code>可以用 Finder 打开当前的位置。</li>
<li>在 Terminal 的偏好里面可以设定它的外观和风格。</li>
<li>中止一个错误的或者发疯的命令，可以使用组合键control + C。</li>
<li>你可以在执行前编辑命令，只需要使用箭头和键盘上的其他字母。</li>
<li>没有输入任何命令时，你可以用▲和▼来浏览历史命令。同样可以编辑和再次执行。</li>
<li>你也可以使用<code>history</code>命令查看历史记录。</li>
<li>你可以使用组合键control + L清屏。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学习苹果认证的《Mac OS X Support Essentials》教程，看到 Command Line 一节有很多实用的知识，下面选取一部分翻译 + 笔记，整理成此文。&lt;/p&gt;
    
    </summary>
    
      <category term="Tutorial" scheme="http://yoursite.com/categories/Tutorial/"/>
    
    
      <category term="Terminal" scheme="http://yoursite.com/tags/Terminal/"/>
    
  </entry>
  
  <entry>
    <title>用纯 CSS 为 HTML checkbox 添加自定义样式及动画效果</title>
    <link href="http://yoursite.com/2017/03/17/Add%20custom%20style%20and%20animation%20effects%20to%20HTML%20checkbox%20with%20CSS/"/>
    <id>http://yoursite.com/2017/03/17/Add custom style and animation effects to HTML checkbox with CSS/</id>
    <published>2017-03-17T06:07:34.000Z</published>
    <updated>2017-09-08T12:18:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般情况下，<code>`元素（也包括一部分其他</code>input<code>元素）是由操作系统（而非浏览器）进行渲染的。在不同操作系统下，这类特殊元素的样式往往和系统本身的风格一致，和浏览器无关。也正是由于这种机制，开发者无法像一般元素那样使用 CSS 来修饰这类元素。这里介绍一种利用纯 CSS 实现自定义 checkbox 样式的方法。思路很简单：由于控件所对应的</code>label<code>元素是可以点击并切换控件状态的，而</code>label<code>元素的样式又可以自由设定，因此我们可将</code>input<code>元素隐藏，通过</code>label`元素实现交互。</p>
<a id="more"></a>
<p>HTML 代码如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;input type="checkbox" id="checkbox" class="checkbox"/&gt;</div><div class="line">&lt;div class="checkbox-wrapper"&gt;</div><div class="line">    &lt;label for="checkbox" class="checkbox-label"&gt;&lt;/label&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<blockquote>
<h2 id="样式一：Metro-UI-风格"><a href="#样式一：Metro-UI-风格" class="headerlink" title="样式一：Metro UI 风格"></a>样式一：Metro UI 风格</h2></blockquote>
<p>效果：</p>
<p>CSS 代码如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.checkbox-wrapper</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">80px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">32px</span>;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">display</span>: inline-block;</div><div class="line">    <span class="attribute">overflow</span>: hidden;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.checkbox</span> &#123;</div><div class="line">    <span class="attribute">display</span>: none;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.checkbox-label</span><span class="selector-pseudo">::before</span>,</div><div class="line"><span class="selector-class">.checkbox-label</span><span class="selector-pseudo">::after</span> &#123;</div><div class="line">    <span class="attribute">font-family</span>: sans-serif;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">13px</span>;</div><div class="line">    <span class="attribute">color</span>: <span class="number">#ffffff</span>;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">font-weight</span>: bold;</div><div class="line">    <span class="attribute">line-height</span>: <span class="number">32px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">32px</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">40px</span>;</div><div class="line">    <span class="attribute">text-align</span>: center;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.checkbox-label</span><span class="selector-pseudo">::before</span> &#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">'ON'</span>;</div><div class="line">    <span class="attribute">left</span>: -<span class="number">40px</span>;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#45b6af</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.checkbox-label</span><span class="selector-pseudo">::after</span> &#123;</div><div class="line">    <span class="attribute">content</span>: <span class="string">'OFF'</span>;</div><div class="line">    <span class="attribute">right</span>: -<span class="number">40px</span>;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#f3565d</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.checkbox-label</span> &#123;</div><div class="line">    <span class="attribute">display</span>: block;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">40px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">32px</span>;</div><div class="line">    <span class="attribute">transition</span>: all .<span class="number">4s</span> ease;</div><div class="line">    <span class="attribute">cursor</span>: pointer;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#dddddd</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.checkbox</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.checkbox-wrapper</span> <span class="selector-class">.checkbox-label</span> &#123;</div><div class="line">    <span class="attribute">left</span>: <span class="number">40px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<h2 id="样式二：iOS-7-风格"><a href="#样式二：iOS-7-风格" class="headerlink" title="样式二：iOS 7 风格"></a>样式二：iOS 7 风格</h2></blockquote>
<p>效果：</p>
<p>CSS代码如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.checkbox-wrapper</span> &#123;</div><div class="line">    <span class="attribute">width</span>: <span class="number">58px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">32px</span>;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">display</span>: inline-block;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#ffffff</span>;</div><div class="line">    <span class="attribute">border-radius</span>: <span class="number">16px</span>;</div><div class="line">    <span class="attribute">transition</span>: all .<span class="number">3s</span> ease-out;</div><div class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">0px</span> <span class="number">2px</span> <span class="number">#ddd</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.checkbox</span> &#123;</div><div class="line">    <span class="attribute">display</span>: none;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.checkbox-label</span> &#123;</div><div class="line">    <span class="attribute">display</span>: block;</div><div class="line">    <span class="attribute">position</span>: absolute;</div><div class="line">    <span class="attribute">left</span>: <span class="number">0px</span>;</div><div class="line">    <span class="attribute">top</span>: <span class="number">0px</span>;</div><div class="line">    <span class="attribute">width</span>: <span class="number">32px</span>;</div><div class="line">    <span class="attribute">height</span>: <span class="number">32px</span>;</div><div class="line">    <span class="attribute">cursor</span>: pointer;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#ffffff</span>;</div><div class="line">    <span class="attribute">border-radius</span>: <span class="number">16px</span>;</div><div class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">2px</span> <span class="number">3px</span> <span class="built_in">rgba</span>(0,0,0,0.2);</div><div class="line">    <span class="attribute">transition</span>: all .<span class="number">3s</span> ease-out;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.checkbox</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.checkbox-wrapper</span> &#123;</div><div class="line">    <span class="attribute">background</span>: <span class="number">#0bd318</span>;</div><div class="line">    <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">0px</span> <span class="number">0px</span> <span class="number">2px</span> <span class="number">#0bd318</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.checkbox</span><span class="selector-pseudo">:checked</span> + <span class="selector-class">.checkbox-wrapper</span> <span class="selector-class">.checkbox-label</span> &#123;</div><div class="line">    <span class="attribute">left</span>: <span class="number">26px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>值得一提的是，这个例子虽然比较完美的还原了 iOS 7 中 UISwitch 控件的外观，但是动画曲线却还有些差距。iOS 7 中使用的是一种名为 String Animation 的动画（该 API 在 iOS 8 中已经公开），仔细看的话可以发现开始滑块移动很快，到后面逐渐变慢，并且结束时还有小幅度的「反弹」效果。这里我们为了方便，使用 ease-out 来模拟。</p>
<blockquote>
<h2 id="JSFiddle"><a href="#JSFiddle" class="headerlink" title="JSFiddle"></a>JSFiddle</h2></blockquote>
<p>点击<a href="http://jsfiddle.net/gnu1qqnq/" target="_blank" rel="external">此处</a>查看本教程在 JSFiddle 的示范代码。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般情况下，&lt;code&gt;`元素（也包括一部分其他&lt;/code&gt;input&lt;code&gt;元素）是由操作系统（而非浏览器）进行渲染的。在不同操作系统下，这类特殊元素的样式往往和系统本身的风格一致，和浏览器无关。也正是由于这种机制，开发者无法像一般元素那样使用 CSS 来修饰这类元素。这里介绍一种利用纯 CSS 实现自定义 checkbox 样式的方法。思路很简单：由于控件所对应的&lt;/code&gt;label&lt;code&gt;元素是可以点击并切换控件状态的，而&lt;/code&gt;label&lt;code&gt;元素的样式又可以自由设定，因此我们可将&lt;/code&gt;input&lt;code&gt;元素隐藏，通过&lt;/code&gt;label`元素实现交互。&lt;/p&gt;
    
    </summary>
    
      <category term="Note" scheme="http://yoursite.com/categories/Note/"/>
    
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
</feed>
